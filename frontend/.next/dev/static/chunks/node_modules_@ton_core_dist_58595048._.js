(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@ton/core/dist/utils/crc16.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crc16 = void 0;
function crc16(data) {
    const poly = 0x1021;
    let reg = 0;
    const message = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(data.length + 2);
    message.set(data);
    for (let byte of message){
        let mask = 0x80;
        while(mask > 0){
            reg <<= 1;
            if (byte & mask) {
                reg += 1;
            }
            mask >>= 1;
            if (reg > 0xffff) {
                reg &= 0xffff;
                reg ^= poly;
            }
        }
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from([
        Math.floor(reg / 256),
        reg % 256
    ]);
}
exports.crc16 = crc16;
}),
"[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.address = exports.Address = void 0;
const symbol_inspect_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/symbol.inspect/index.js [client] (ecmascript)"));
const crc16_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/crc16.js [client] (ecmascript)");
const bounceable_tag = 0x11;
const non_bounceable_tag = 0x51;
const test_flag = 0x80;
function parseFriendlyAddress(src) {
    if (typeof src === 'string' && !Address.isFriendly(src)) {
        throw new Error('Unknown address type');
    }
    const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(src) ? src : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(src, 'base64');
    // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc
    if (data.length !== 36) {
        throw new Error('Unknown address type: byte length is not equal to 36');
    }
    // Prepare data
    const addr = data.subarray(0, 34);
    const crc = data.subarray(34, 36);
    const calcedCrc = (0, crc16_1.crc16)(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
        throw new Error('Invalid checksum: ' + src);
    }
    // Parse tag
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
        isTestOnly = true;
        tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag) throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 0xff) {
        workchain = -1;
    } else {
        workchain = addr[1];
    }
    const hashPart = addr.subarray(2, 34);
    return {
        isTestOnly,
        isBounceable,
        workchain,
        hashPart
    };
}
class Address {
    static isAddress(src) {
        return src instanceof Address;
    }
    static isFriendly(source) {
        // Check length
        if (source.length !== 48) {
            return false;
        }
        // Check if address is valid base64
        if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
            return false;
        }
        return true;
    }
    static isRaw(source) {
        // Check if has delimiter
        if (source.indexOf(':') === -1) {
            return false;
        }
        let [wc, hash] = source.split(':');
        // wc is not valid
        if (!Number.isInteger(parseFloat(wc))) {
            return false;
        }
        // hash is not valid
        if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
            return false;
        }
        // has is not correct
        if (hash.length !== 64) {
            return false;
        }
        return true;
    }
    static normalize(source) {
        if (typeof source === 'string') {
            return Address.parse(source).toString();
        } else {
            return source.toString();
        }
    }
    static parse(source) {
        if (Address.isFriendly(source)) {
            return this.parseFriendly(source).address;
        } else if (Address.isRaw(source)) {
            return this.parseRaw(source);
        } else {
            throw new Error('Unknown address type: ' + source);
        }
    }
    static parseRaw(source) {
        let workChain = parseInt(source.split(":")[0]);
        let hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(source.split(":")[1], 'hex');
        return new Address(workChain, hash);
    }
    static parseFriendly(source) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(source)) {
            let r = parseFriendlyAddress(source);
            return {
                isBounceable: r.isBounceable,
                isTestOnly: r.isTestOnly,
                address: new Address(r.workchain, r.hashPart)
            };
        } else {
            let addr = source.replace(/\-/g, '+').replace(/_/g, '\/'); // Convert from url-friendly to true base64
            let r = parseFriendlyAddress(addr);
            return {
                isBounceable: r.isBounceable,
                isTestOnly: r.isTestOnly,
                address: new Address(r.workchain, r.hashPart)
            };
        }
    }
    constructor(workChain, hash){
        this.toRawString = ()=>{
            return this.workChain + ':' + this.hash.toString('hex');
        };
        this.toRaw = ()=>{
            const addressWithChecksum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(36);
            addressWithChecksum.set(this.hash);
            addressWithChecksum.set([
                this.workChain,
                this.workChain,
                this.workChain,
                this.workChain
            ], 32);
            return addressWithChecksum;
        };
        this.toStringBuffer = (args)=>{
            let testOnly = args && args.testOnly !== undefined ? args.testOnly : false;
            let bounceable = args && args.bounceable !== undefined ? args.bounceable : true;
            let tag = bounceable ? bounceable_tag : non_bounceable_tag;
            if (testOnly) {
                tag |= test_flag;
            }
            const addr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(34);
            addr[0] = tag;
            addr[1] = this.workChain;
            addr.set(this.hash, 2);
            const addressWithChecksum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(36);
            addressWithChecksum.set(addr);
            addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
            return addressWithChecksum;
        };
        this.toString = (args)=>{
            let urlSafe = args && args.urlSafe !== undefined ? args.urlSafe : true;
            let buffer = this.toStringBuffer(args);
            if (urlSafe) {
                return buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
            } else {
                return buffer.toString('base64');
            }
        };
        this[_a] = ()=>this.toString();
        if (hash.length !== 32) {
            throw new Error('Invalid address hash length: ' + hash.length);
        }
        this.workChain = workChain;
        this.hash = hash;
        Object.freeze(this);
    }
    equals(src) {
        if (src.workChain !== this.workChain) {
            return false;
        }
        return src.hash.equals(this.hash);
    }
}
exports.Address = Address;
_a = symbol_inspect_1.default;
function address(src) {
    return Address.parse(src);
}
exports.address = address;
}),
"[project]/node_modules/@ton/core/dist/address/ExternalAddress.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExternalAddress = void 0;
const symbol_inspect_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/symbol.inspect/index.js [client] (ecmascript)"));
class ExternalAddress {
    static isAddress(src) {
        return src instanceof ExternalAddress;
    }
    constructor(value, bits){
        this[_a] = ()=>this.toString();
        this.value = value;
        this.bits = bits;
    }
    toString() {
        return `External<${this.bits}:${this.value}>`;
    }
}
exports.ExternalAddress = ExternalAddress;
_a = symbol_inspect_1.default;
}),
"[project]/node_modules/@ton/core/dist/utils/base32.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.base32Decode = exports.base32Encode = void 0;
const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
function base32Encode(buffer) {
    const length = buffer.byteLength;
    let bits = 0;
    let value = 0;
    let output = '';
    for(let i = 0; i < length; i++){
        value = value << 8 | buffer[i];
        bits += 8;
        while(bits >= 5){
            output += alphabet[value >>> bits - 5 & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
    }
    return output;
}
exports.base32Encode = base32Encode;
function readChar(alphabet, char) {
    const idx = alphabet.indexOf(char);
    if (idx === -1) {
        throw new Error('Invalid character found: ' + char);
    }
    return idx;
}
function base32Decode(input) {
    let cleanedInput;
    cleanedInput = input.toLowerCase();
    const { length } = cleanedInput;
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(length * 5 / 8 | 0);
    for(let i = 0; i < length; i++){
        value = value << 5 | readChar(alphabet, cleanedInput[i]);
        bits += 5;
        if (bits >= 8) {
            output[index++] = value >>> bits - 8 & 255;
            bits -= 8;
        }
    }
    return output;
}
exports.base32Decode = base32Decode;
}),
"[project]/node_modules/@ton/core/dist/address/ADNLAddress.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ADNLAddress = void 0;
const symbol_inspect_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/symbol.inspect/index.js [client] (ecmascript)"));
const base32_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/base32.js [client] (ecmascript)");
const crc16_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/crc16.js [client] (ecmascript)");
class ADNLAddress {
    static parseFriendly(src) {
        if (src.length !== 55) {
            throw Error('Invalid address');
        }
        // Decoding
        src = 'f' + src;
        let decoded = (0, base32_1.base32Decode)(src);
        if (decoded[0] !== 0x2d) {
            throw Error('Invalid address');
        }
        let gotHash = decoded.slice(33);
        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
        if (!hash.equals(gotHash)) {
            throw Error('Invalid address');
        }
        return new ADNLAddress(decoded.slice(1, 33));
    }
    static parseRaw(src) {
        const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(src, 'base64');
        return new ADNLAddress(data);
    }
    constructor(address){
        this.toRaw = ()=>{
            return this.address.toString('hex').toUpperCase();
        };
        this.toString = ()=>{
            let data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from([
                    0x2D
                ]),
                this.address
            ]);
            let hash = (0, crc16_1.crc16)(data);
            data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                data,
                hash
            ]);
            return (0, base32_1.base32Encode)(data).slice(1);
        };
        this[_a] = ()=>this.toString();
        if (address.length !== 32) {
            throw Error('Invalid address');
        }
        this.address = address;
    }
    equals(b) {
        return this.address.equals(b.address);
    }
}
exports.ADNLAddress = ADNLAddress;
_a = symbol_inspect_1.default;
}),
"[project]/node_modules/@ton/core/dist/boc/utils/paddedBits.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.paddedBufferToBits = exports.bitsToPaddedBuffer = void 0;
const BitBuilder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitBuilder.js [client] (ecmascript)");
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
function bitsToPaddedBuffer(bits) {
    // Create builder
    let builder = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
    builder.writeBits(bits);
    // Apply padding
    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
    for(let i = 0; i < padding; i++){
        if (i === 0) {
            builder.writeBit(1);
        } else {
            builder.writeBit(0);
        }
    }
    return builder.buffer();
}
exports.bitsToPaddedBuffer = bitsToPaddedBuffer;
function paddedBufferToBits(buff) {
    let bitLen = 0;
    // Finding rightmost non-zero byte in the buffer
    for(let i = buff.length - 1; i >= 0; i--){
        if (buff[i] !== 0) {
            const testByte = buff[i];
            // Looking for a rightmost set padding bit
            let bitPos = testByte & -testByte;
            if ((bitPos & 1) == 0) {
                // It's power of 2 (only one bit set)
                bitPos = Math.log2(bitPos) + 1;
            }
            if (i > 0) {
                // If we are dealing with more than 1 byte buffer
                bitLen = i << 3; //Number of full bytes * 8
            }
            bitLen += 8 - bitPos;
            break;
        }
    }
    return new BitString_1.BitString(buff, 0, bitLen);
}
exports.paddedBufferToBits = paddedBufferToBits;
}),
"[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitString = void 0;
const paddedBits_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/utils/paddedBits.js [client] (ecmascript)");
const symbol_inspect_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/symbol.inspect/index.js [client] (ecmascript)"));
/**
 * BitString is a class that represents a bitstring in a buffer with a specified offset and length
 */ class BitString {
    /**
     * Checks if supplied object is BitString
     * @param src is unknow object
     * @returns true if object is BitString and false otherwise
     **/ static isBitString(src) {
        return src instanceof BitString;
    }
    /**
     * Constructing BitString from a buffer
     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
     * @param offset offset in bits from the start of the buffer
     * @param length length of the bitstring in bits
     */ constructor(data, offset, length){
        this[_a] = ()=>this.toString();
        // Check bounds
        if (length < 0) {
            throw new Error(`Length ${length} is out of bounds`);
        }
        this._length = length;
        this._data = data;
        this._offset = offset;
    }
    /**
     * Returns the length of the bitstring
     */ get length() {
        return this._length;
    }
    /**
     * Returns the bit at the specified index
     * @param index index of the bit
     * @throws Error if index is out of bounds
     * @returns true if the bit is set, false otherwise
     */ at(index) {
        // Check bounds
        if (index >= this._length) {
            throw new Error(`Index ${index} > ${this._length} is out of bounds`);
        }
        if (index < 0) {
            throw new Error(`Index ${index} < 0 is out of bounds`);
        }
        // Calculcate offsets
        let byteIndex = this._offset + index >> 3;
        let bitIndex = 7 - (this._offset + index) % 8; // NOTE: We are using big endian
        // Return the bit
        return (this._data[byteIndex] & 1 << bitIndex) !== 0;
    }
    /**
     * Get a subscring of the bitstring
     * @param offset
     * @param length
     * @returns
     */ substring(offset, length) {
        // Check offset
        if (offset > this._length) {
            throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
        }
        if (offset < 0) {
            throw new Error(`Offset(${offset}) < 0 is out of bounds`);
        }
        // Corner case of empty string
        if (length === 0) {
            return BitString.EMPTY;
        }
        if (offset + length > this._length) {
            throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
        }
        // Create substring
        return new BitString(this._data, this._offset + offset, length);
    }
    /**
     * Try to get a buffer from the bitstring without allocations
     * @param offset offset in bits
     * @param length length in bits
     * @returns buffer if the bitstring is aligned to bytes, null otherwise
     */ subbuffer(offset, length) {
        // Check offset
        if (offset > this._length) {
            throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset < 0) {
            throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset + length > this._length) {
            throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
        }
        // Check alignment
        if (length % 8 !== 0) {
            return null;
        }
        if ((this._offset + offset) % 8 !== 0) {
            return null;
        }
        // Create substring
        let start = this._offset + offset >> 3;
        let end = start + (length >> 3);
        return this._data.subarray(start, end);
    }
    /**
     * Checks for equality
     * @param b other bitstring
     * @returns true if the bitstrings are equal, false otherwise
     */ equals(b) {
        if (this._length !== b._length) {
            return false;
        }
        for(let i = 0; i < this._length; i++){
            if (this.at(i) !== b.at(i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Format to canonical string
     * @returns formatted bits as a string
     */ toString() {
        const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
        if (this._length % 4 === 0) {
            const s = padded.subarray(0, Math.ceil(this._length / 8)).toString('hex').toUpperCase();
            if (this._length % 8 === 0) {
                return s;
            } else {
                return s.substring(0, s.length - 1);
            }
        } else {
            const hex = padded.toString('hex').toUpperCase();
            if (this._length % 8 <= 4) {
                return hex.substring(0, hex.length - 1) + '_';
            } else {
                return hex + '_';
            }
        }
    }
}
exports.BitString = BitString;
_a = symbol_inspect_1.default;
BitString.EMPTY = new BitString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0), 0, 0);
}),
"[project]/node_modules/@ton/core/dist/boc/BitBuilder.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitBuilder = void 0;
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
const ExternalAddress_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/ExternalAddress.js [client] (ecmascript)");
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
/**
 * Class for building bit strings
 */ class BitBuilder {
    constructor(size = 1023){
        this._buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(Math.ceil(size / 8));
        this._length = 0;
    }
    /**
     * Current number of bits written
     */ get length() {
        return this._length;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     */ writeBit(value) {
        // Check overflow
        let n = this._length;
        if (n > this._buffer.length * 8) {
            throw new Error("BitBuilder overflow");
        }
        // Set bit
        if (typeof value === 'boolean' && value === true || typeof value === 'number' && value > 0) {
            this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
        }
        // Advance
        this._length++;
    }
    /**
     * Copy bits from BitString
     * @param src source bits
     */ writeBits(src) {
        for(let i = 0; i < src.length; i++){
            this.writeBit(src.at(i));
        }
    }
    /**
     * Write bits from buffer
     * @param src source buffer
     */ writeBuffer(src) {
        // Special case for aligned offsets
        if (this._length % 8 === 0) {
            if (this._length + src.length * 8 > this._buffer.length * 8) {
                throw new Error("BitBuilder overflow");
            }
            src.copy(this._buffer, this._length / 8);
            this._length += src.length * 8;
        } else {
            for(let i = 0; i < src.length; i++){
                this.writeUint(src[i], 8);
            }
        }
    }
    /**
     * Write uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */ writeUint(value, bits) {
        if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
        }
        const v = BigInt(value);
        if (bits === 0) {
            if (v !== 0n) {
                throw Error(`value is not zero for ${bits} bits. Got ${value}`);
            } else {
                return;
            }
        }
        const vBits = 1n << BigInt(bits);
        if (v < 0 || v >= vBits) {
            throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
        }
        if (this._length + bits > this._buffer.length * 8) {
            throw new Error("BitBuilder overflow");
        }
        const tillByte = 8 - this._length % 8;
        if (tillByte > 0) {
            const bidx = Math.floor(this._length / 8);
            if (bits < tillByte) {
                const wb = Number(v);
                this._buffer[bidx] |= wb << tillByte - bits;
                this._length += bits;
            } else {
                const wb = Number(v >> BigInt(bits - tillByte));
                this._buffer[bidx] |= wb;
                this._length += tillByte;
            }
        }
        bits -= tillByte;
        while(bits > 0){
            if (bits >= 8) {
                this._buffer[this._length / 8] = Number(v >> BigInt(bits - 8) & 0xffn);
                this._length += 8;
                bits -= 8;
            } else {
                this._buffer[this._length / 8] = Number(v << BigInt(8 - bits) & 0xffn);
                this._length += bits;
                bits = 0;
            }
        }
    }
    /**
     * Write int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     */ writeInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
        }
        // Corner case for zero bits
        if (bits === 0) {
            if (v !== 0n) {
                throw Error(`value is not zero for ${bits} bits. Got ${value}`);
            } else {
                return;
            }
        }
        // Corner case for one bit
        if (bits === 1) {
            if (v !== -1n && v !== 0n) {
                throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
            } else {
                this.writeBit(v === -1n);
                return;
            }
        }
        // Check input
        let vBits = 1n << BigInt(bits) - 1n;
        if (v < -vBits || v >= vBits) {
            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
        }
        // Write sign
        if (v < 0) {
            this.writeBit(true);
            v = vBits + v;
        } else {
            this.writeBit(false);
        }
        // Write value
        this.writeUint(v, bits - 1);
    }
    /**
     * Wrtie var uint value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */ writeVarUint(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v < 0) {
            throw Error(`value is negative. Got ${value}`);
        }
        // Corner case for zero
        if (v === 0n) {
            // Write zero size
            this.writeUint(0, bits);
            return;
        }
        // Calculate size
        const sizeBytes = Math.ceil(v.toString(2).length / 8); // Fastest way in most environments
        const sizeBits = sizeBytes * 8;
        // Write size
        this.writeUint(sizeBytes, bits);
        // Write number
        this.writeUint(v, sizeBits);
    }
    /**
     * Wrtie var int value, used for serializing coins
     * @param value value to write as bigint or number
     * @param bits header bits to write size
     */ writeVarInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
            throw Error(`invalid bit length. Got ${bits}`);
        }
        // Corner case for zero
        if (v === 0n) {
            // Write zero size
            this.writeUint(0, bits);
            return;
        }
        // Calculate size
        let v2 = v > 0 ? v : -v;
        const sizeBytes = Math.ceil((v2.toString(2).length + 1) / 8); // Fastest way in most environments
        const sizeBits = sizeBytes * 8;
        // Write size
        this.writeUint(sizeBytes, bits);
        // Write number
        this.writeInt(v, sizeBits);
    }
    /**
     * Write coins in var uint format
     * @param amount amount to write
     */ writeCoins(amount) {
        this.writeVarUint(amount, 4);
    }
    /**
     * Write address
     * @param address write address or address external
     */ writeAddress(address) {
        // Is empty address
        if (address === null || address === undefined) {
            this.writeUint(0, 2); // Empty address
            return;
        }
        // Is Internal Address
        if (Address_1.Address.isAddress(address)) {
            this.writeUint(2, 2); // Internal address
            this.writeUint(0, 1); // No anycast
            this.writeInt(address.workChain, 8);
            this.writeBuffer(address.hash);
            return;
        }
        // Is External Address
        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
            this.writeUint(1, 2); // External address
            this.writeUint(address.bits, 9);
            this.writeUint(address.value, address.bits);
            return;
        }
        // Invalid address
        throw Error(`Invalid address. Got ${address}`);
    }
    /**
     * Build BitString
     * @returns result bit string
     */ build() {
        return new BitString_1.BitString(this._buffer, 0, this._length);
    }
    /**
     * Build into Buffer
     * @returns result buffer
     */ buffer() {
        if (this._length % 8 !== 0) {
            throw new Error("BitBuilder buffer is not byte aligned");
        }
        return this._buffer.subarray(0, this._length / 8);
    }
}
exports.BitBuilder = BitBuilder;
}),
"[project]/node_modules/@ton/core/dist/boc/CellType.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellType = void 0;
var CellType;
(function(CellType) {
    CellType[CellType["Ordinary"] = -1] = "Ordinary";
    CellType[CellType["PrunedBranch"] = 1] = "PrunedBranch";
    CellType[CellType["Library"] = 2] = "Library";
    CellType[CellType["MerkleProof"] = 3] = "MerkleProof";
    CellType[CellType["MerkleUpdate"] = 4] = "MerkleUpdate";
})(CellType || (exports.CellType = CellType = {}));
}),
"[project]/node_modules/@ton/core/dist/dict/utils/readUnaryLength.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readUnaryLength = void 0;
function readUnaryLength(slice) {
    let res = 0;
    while(slice.loadBit()){
        res++;
    }
    return res;
}
exports.readUnaryLength = readUnaryLength;
}),
"[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitReader = void 0;
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
const ExternalAddress_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/ExternalAddress.js [client] (ecmascript)");
/**
 * Class for reading bit strings
 */ class BitReader {
    constructor(bits, offset = 0){
        this._checkpoints = [];
        this._bits = bits;
        this._offset = offset;
    }
    /**
     * Offset in source bit string
     */ get offset() {
        return this._offset;
    }
    /**
     * Number of bits remaining
     */ get remaining() {
        return this._bits.length - this._offset;
    }
    /**
     * Skip bits
     * @param bits number of bits to skip
     */ skip(bits) {
        if (bits < 0 || this._offset + bits > this._bits.length) {
            throw new Error(`Index ${this._offset + bits} is out of bounds`);
        }
        this._offset += bits;
    }
    /**
     * Reset to the beginning or latest checkpoint
     */ reset() {
        if (this._checkpoints.length > 0) {
            this._offset = this._checkpoints.pop();
        } else {
            this._offset = 0;
        }
    }
    /**
     * Save checkpoint
     */ save() {
        this._checkpoints.push(this._offset);
    }
    /**
     * Load a single bit
     * @returns true if the bit is set, false otherwise
     */ loadBit() {
        let r = this._bits.at(this._offset);
        this._offset++;
        return r;
    }
    /**
     * Preload bit
     * @returns true if the bit is set, false otherwise
     */ preloadBit() {
        return this._bits.at(this._offset);
    }
    /**
     * Load bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */ loadBits(bits) {
        let r = this._bits.substring(this._offset, bits);
        this._offset += bits;
        return r;
    }
    /**
     * Preload bit string
     * @param bits number of bits to read
     * @returns new bitstring
     */ preloadBits(bits) {
        return this._bits.substring(this._offset, bits);
    }
    /**
     * Load buffer
     * @param bytes number of bytes
     * @returns new buffer
     */ loadBuffer(bytes) {
        let buf = this._preloadBuffer(bytes, this._offset);
        this._offset += bytes * 8;
        return buf;
    }
    /**
     * Preload buffer
     * @param bytes number of bytes
     * @returns new buffer
     */ preloadBuffer(bytes) {
        return this._preloadBuffer(bytes, this._offset);
    }
    /**
     * Load uint value
     * @param bits uint bits
     * @returns read value as number
     */ loadUint(bits) {
        return this._toSafeInteger(this.loadUintBig(bits), 'loadUintBig');
    }
    /**
     * Load uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */ loadUintBig(bits) {
        let loaded = this.preloadUintBig(bits);
        this._offset += bits;
        return loaded;
    }
    /**
     * Preload uint value
     * @param bits uint bits
     * @returns read value as number
     */ preloadUint(bits) {
        return this._toSafeInteger(this._preloadUint(bits, this._offset), 'preloadUintBig');
    }
    /**
     * Preload uint value as bigint
     * @param bits uint bits
     * @returns read value as bigint
     */ preloadUintBig(bits) {
        return this._preloadUint(bits, this._offset);
    }
    /**
     * Load int value
     * @param bits int bits
     * @returns read value as bigint
     */ loadInt(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return this._toSafeInteger(res, 'loadUintBig');
    }
    /**
     * Load int value as bigint
     * @param bits int bits
     * @returns read value as bigint
     */ loadIntBig(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return res;
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */ preloadInt(bits) {
        return this._toSafeInteger(this._preloadInt(bits, this._offset), 'preloadIntBig');
    }
    /**
     * Preload int value
     * @param bits int bits
     * @returns read value as bigint
     */ preloadIntBig(bits) {
        return this._preloadInt(bits, this._offset);
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ loadVarUint(bits) {
        let size = Number(this.loadUint(bits));
        return this._toSafeInteger(this.loadUintBig(size * 8), 'loadVarUintBig');
    }
    /**
     * Load varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ loadVarUintBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadUintBig(size * 8);
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ preloadVarUint(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), 'preloadVarUintBig');
    }
    /**
     * Preload varuint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ preloadVarUintBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadUint(size * 8, this._offset + bits);
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ loadVarInt(bits) {
        let size = Number(this.loadUint(bits));
        return this._toSafeInteger(this.loadIntBig(size * 8), 'loadVarIntBig');
    }
    /**
     * Load varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ loadVarIntBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadIntBig(size * 8);
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ preloadVarInt(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), 'preloadVarIntBig');
    }
    /**
     * Preload varint value
     * @param bits number of bits to read the size
     * @returns read value as bigint
     */ preloadVarIntBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadInt(size * 8, this._offset + bits);
    }
    /**
     * Load coins value
     * @returns read value as bigint
     */ loadCoins() {
        return this.loadVarUintBig(4);
    }
    /**
     * Preload coins value
     * @returns read value as bigint
     */ preloadCoins() {
        return this.preloadVarUintBig(4);
    }
    /**
     * Load Address
     * @returns Address
     */ loadAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 2) {
            return this._loadInternalAddress();
        } else {
            throw new Error("Invalid address: " + type);
        }
    }
    /**
     * Load internal address
     * @returns Address or null
     */ loadMaybeAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
            this._offset += 2;
            return null;
        } else if (type === 2) {
            return this._loadInternalAddress();
        } else {
            throw new Error("Invalid address");
        }
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */ loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 1) {
            return this._loadExternalAddress();
        } else {
            throw new Error("Invalid address");
        }
    }
    /**
     * Load external address
     * @returns ExternalAddress or null
     */ loadMaybeExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
            this._offset += 2;
            return null;
        } else if (type === 1) {
            return this._loadExternalAddress();
        } else {
            throw new Error("Invalid address");
        }
    }
    /**
     * Read address of any type
     * @returns Address or ExternalAddress or null
     */ loadAddressAny() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
            this._offset += 2;
            return null;
        } else if (type === 2) {
            return this._loadInternalAddress();
        } else if (type === 1) {
            return this._loadExternalAddress();
        } else if (type === 3) {
            throw Error('Unsupported');
        } else {
            throw Error('Unreachable');
        }
    }
    /**
     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
     * @param bytes number of bytes to read
     */ loadPaddedBits(bits) {
        // Check that number of bits is byte alligned
        if (bits % 8 !== 0) {
            throw new Error("Invalid number of bits");
        }
        // Skip padding
        let length = bits;
        while(true){
            if (this._bits.at(this._offset + length - 1)) {
                length--;
                break;
            } else {
                length--;
            }
        }
        // Read substring
        let r = this._bits.substring(this._offset, length);
        this._offset += bits;
        return r;
    }
    /**
     * Clone BitReader
     */ clone() {
        return new BitReader(this._bits, this._offset);
    }
    /**
     * Preload int from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */ _preloadInt(bits, offset) {
        if (bits == 0) {
            return 0n;
        }
        let sign = this._bits.at(offset);
        let res = 0n;
        for(let i = 0; i < bits - 1; i++){
            if (this._bits.at(offset + 1 + i)) {
                res += 1n << BigInt(bits - i - 1 - 1);
            }
        }
        if (sign) {
            res = res - (1n << BigInt(bits - 1));
        }
        return res;
    }
    /**
     * Preload uint from specific offset
     * @param bits bits to preload
     * @param offset offset to start from
     * @returns read value as bigint
     */ _preloadUint(bits, offset) {
        if (bits == 0) {
            return 0n;
        }
        let res = 0n;
        for(let i = 0; i < bits; i++){
            if (this._bits.at(offset + i)) {
                res += 1n << BigInt(bits - i - 1);
            }
        }
        return res;
    }
    _preloadBuffer(bytes, offset) {
        // Try to load fast
        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
        if (fastBuffer) {
            return fastBuffer;
        }
        // Load slow
        let buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(bytes);
        for(let i = 0; i < bytes; i++){
            buf[i] = Number(this._preloadUint(8, offset + i * 8));
        }
        return buf;
    }
    _loadInternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 2) {
            throw Error('Invalid address');
        }
        // Handle Anycast
        let rewrite_pfx = undefined;
        let rewrite_depth = undefined;
        if (this._preloadUint(1, this._offset + 2) !== 0n) {
            rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
            rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
            this._offset += 5 + rewrite_depth;
        }
        // Read address
        let wc = Number(this._preloadInt(8, this._offset + 3));
        let hash = this._preloadBuffer(32, this._offset + 11);
        // Apply rewrite prefix if present
        if (rewrite_depth !== undefined && rewrite_pfx !== undefined) {
            let pfx = Number(rewrite_pfx);
            let byteIndex = 0;
            let bitIndex = 0;
            let bitsRemaining = rewrite_depth;
            while(bitsRemaining > 0){
                let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
                let mask = (1 << bitsInThisByte) - 1 << 8 - bitIndex - bitsInThisByte;
                let bits = (pfx >> bitsRemaining - bitsInThisByte & (1 << bitsInThisByte) - 1) << 8 - bitIndex - bitsInThisByte;
                hash[byteIndex] = hash[byteIndex] & ~mask | bits;
                bitsRemaining -= bitsInThisByte;
                bitIndex += bitsInThisByte;
                if (bitIndex === 8) {
                    byteIndex++;
                    bitIndex = 0;
                }
            }
        }
        // Update offset
        this._offset += 267;
        return new Address_1.Address(wc, hash);
    }
    _loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 1) {
            throw Error('Invalid address');
        }
        // Load length
        let bits = Number(this._preloadUint(9, this._offset + 2));
        // Load address
        let value = this._preloadUint(bits, this._offset + 11);
        // Update offset
        this._offset += 11 + bits;
        return new ExternalAddress_1.ExternalAddress(value, bits);
    }
    _toSafeInteger(src, alt) {
        if (BigInt(Number.MAX_SAFE_INTEGER) < src || src < BigInt(Number.MIN_SAFE_INTEGER)) {
            throw new TypeError(`${src} is out of safe integer range. Use ${alt} instead`);
        }
        return Number(src);
    }
}
exports.BitReader = BitReader;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertToMerkleProof = exports.exoticMerkleProof = void 0;
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
function exoticMerkleProof(bits, refs) {
    const reader = new BitReader_1.BitReader(bits);
    // type + hash + depth
    const size = 8 + 256 + 16;
    if (bits.length !== size) {
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
    }
    if (refs.length !== 1) {
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
    }
    // Check type
    let type = reader.loadUint(8);
    if (type !== 3) {
        throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
    }
    // Check data
    const proofHash = reader.loadBuffer(32);
    const proofDepth = reader.loadUint(16);
    const refHash = refs[0].hash(0);
    const refDepth = refs[0].depth(0);
    if (proofDepth !== refDepth) {
        throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
    }
    if (!proofHash.equals(refHash)) {
        throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString('hex')}", got "${refHash.toString('hex')}"`);
    }
    return {
        proofDepth,
        proofHash
    };
}
exports.exoticMerkleProof = exoticMerkleProof;
function convertToMerkleProof(c) {
    return (0, Builder_1.beginCell)().storeUint(3, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).storeRef(c).endCell({
        exotic: true
    });
}
exports.convertToMerkleProof = convertToMerkleProof;
}),
"[project]/node_modules/@ton/core/dist/dict/generateMerkleProof.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateMerkleProof = exports.generateMerkleProofDirect = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const readUnaryLength_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/utils/readUnaryLength.js [client] (ecmascript)");
const exoticMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js [client] (ecmascript)");
function convertToPrunedBranch(c) {
    return (0, Builder_1.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(c.hash(0)).storeUint(c.depth(0), 16).endCell({
        exotic: true
    });
}
function doGenerateMerkleProof(prefix, slice, n, keys) {
    // Reading label
    const originalCell = slice.asCell();
    if (keys.length == 0) {
        // no keys to prove, prune the whole subdict
        return convertToPrunedBranch(originalCell);
    }
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
        // Short label detected
        // Read
        prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
        // Read prefix
        for(let i = 0; i < prefixLength; i++){
            pp += slice.loadBit() ? '1' : '0';
        }
    } else {
        let lb1 = slice.loadBit() ? 1 : 0;
        if (lb1 === 0) {
            // Long label detected
            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
            for(let i = 0; i < prefixLength; i++){
                pp += slice.loadBit() ? '1' : '0';
            }
        } else {
            // Same label detected
            let bit = slice.loadBit() ? '1' : '0';
            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
            for(let i = 0; i < prefixLength; i++){
                pp += bit;
            }
        }
    }
    if (n - prefixLength === 0) {
        return originalCell;
    } else {
        let sl = originalCell.beginParse();
        let left = sl.loadRef();
        let right = sl.loadRef();
        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'
        if (!left.isExotic) {
            const leftKeys = keys.filter((key)=>{
                return pp + '0' === key.slice(0, pp.length + 1);
            });
            left = doGenerateMerkleProof(pp + '0', left.beginParse(), n - prefixLength - 1, leftKeys);
        }
        if (!right.isExotic) {
            const rightKeys = keys.filter((key)=>{
                return pp + '1' === key.slice(0, pp.length + 1);
            });
            right = doGenerateMerkleProof(pp + '1', right.beginParse(), n - prefixLength - 1, rightKeys);
        }
        return (0, Builder_1.beginCell)().storeSlice(sl).storeRef(left).storeRef(right).endCell();
    }
}
function generateMerkleProofDirect(dict, keys, keyObject) {
    keys.forEach((key)=>{
        if (!dict.has(key)) {
            throw new Error(`Trying to generate merkle proof for a missing key "${key}"`);
        }
    });
    const s = (0, Builder_1.beginCell)().storeDictDirect(dict).asSlice();
    return doGenerateMerkleProof('', s, keyObject.bits, keys.map((key)=>keyObject.serialize(key).toString(2).padStart(keyObject.bits, '0')));
}
exports.generateMerkleProofDirect = generateMerkleProofDirect;
function generateMerkleProof(dict, keys, keyObject) {
    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
}
exports.generateMerkleProof = generateMerkleProof;
}),
"[project]/node_modules/@ton/core/dist/dict/generateMerkleUpdate.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateMerkleUpdate = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const generateMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/generateMerkleProof.js [client] (ecmascript)");
function convertToMerkleUpdate(c1, c2) {
    return (0, Builder_1.beginCell)().storeUint(4, 8).storeBuffer(c1.hash(0)).storeBuffer(c2.hash(0)).storeUint(c1.depth(0), 16).storeUint(c2.depth(0), 16).storeRef(c1).storeRef(c2).endCell({
        exotic: true
    });
}
function generateMerkleUpdate(dict, key, keyObject, newValue) {
    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [
        key
    ], keyObject).refs[0];
    dict.set(key, newValue);
    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [
        key
    ], keyObject).refs[0];
    return convertToMerkleUpdate(oldProof, newProof);
}
exports.generateMerkleUpdate = generateMerkleUpdate;
}),
"[project]/node_modules/@ton/core/dist/dict/parseDict.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseDict = void 0;
function readUnaryLength(slice) {
    let res = 0;
    while(slice.loadBit()){
        res++;
    }
    return res;
}
function doParse(prefix, slice, n, res, extractor) {
    // Reading label
    let lb0 = slice.loadBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
        // Short label detected
        // Read 
        prefixLength = readUnaryLength(slice);
        // Read prefix
        for(let i = 0; i < prefixLength; i++){
            pp += slice.loadBit() ? '1' : '0';
        }
    } else {
        let lb1 = slice.loadBit() ? 1 : 0;
        if (lb1 === 0) {
            // Long label detected
            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
            for(let i = 0; i < prefixLength; i++){
                pp += slice.loadBit() ? '1' : '0';
            }
        } else {
            // Same label detected
            let bit = slice.loadBit() ? '1' : '0';
            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
            for(let i = 0; i < prefixLength; i++){
                pp += bit;
            }
        }
    }
    if (n - prefixLength === 0) {
        res.set(BigInt('0b' + pp), extractor(slice));
    } else {
        let left = slice.loadRef();
        let right = slice.loadRef();
        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'
        if (!left.isExotic) {
            doParse(pp + '0', left.beginParse(), n - prefixLength - 1, res, extractor);
        }
        if (!right.isExotic) {
            doParse(pp + '1', right.beginParse(), n - prefixLength - 1, res, extractor);
        }
    }
}
function parseDict(sc, keySize, extractor) {
    let res = new Map();
    if (sc) {
        doParse('', sc, keySize, res, extractor);
    }
    return res;
}
exports.parseDict = parseDict;
}),
"[project]/node_modules/@ton/core/dist/dict/utils/findCommonPrefix.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findCommonPrefix = void 0;
function findCommonPrefix(src, startPos = 0) {
    // Corner cases
    if (src.length === 0) {
        return '';
    }
    let r = src[0].slice(startPos);
    for(let i = 1; i < src.length; i++){
        const s = src[i];
        while(s.indexOf(r, startPos) !== startPos){
            r = r.substring(0, r.length - 1);
            if (r === '') {
                return r;
            }
        }
    }
    return r;
}
exports.findCommonPrefix = findCommonPrefix;
}),
"[project]/node_modules/@ton/core/dist/dict/serializeDict.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const findCommonPrefix_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/utils/findCommonPrefix.js [client] (ecmascript)");
//
// Tree Build
//
function pad(src, size) {
    while(src.length < size){
        src = '0' + src;
    }
    return src;
}
function removePrefixMap(src, length) {
    if (length === 0) {
        return src;
    } else {
        let res = new Map();
        for (let k of src.keys()){
            let d = src.get(k);
            res.set(k.slice(length), d);
        }
        return res;
    }
}
function forkMap(src, prefixLen) {
    if (src.size === 0) {
        throw Error('Internal inconsistency');
    }
    let left = new Map();
    let right = new Map();
    for (let [k, d] of src.entries()){
        if (k[prefixLen] === '0') {
            left.set(k, d);
        } else {
            right.set(k, d);
        }
    }
    if (left.size === 0) {
        throw Error('Internal inconsistency. Left emtpy.');
    }
    if (right.size === 0) {
        throw Error('Internal inconsistency. Right emtpy.');
    }
    return {
        left,
        right
    };
}
function buildNode(src, prefixLen) {
    if (src.size === 0) {
        throw Error('Internal inconsistency');
    }
    if (src.size === 1) {
        return {
            type: 'leaf',
            value: Array.from(src.values())[0]
        };
    }
    let { left, right } = forkMap(src, prefixLen);
    return {
        type: 'fork',
        left: buildEdge(left, prefixLen + 1),
        right: buildEdge(right, prefixLen + 1)
    };
}
function buildEdge(src, prefixLen = 0) {
    if (src.size === 0) {
        throw Error('Internal inconsistency');
    }
    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);
    return {
        label,
        node: buildNode(src, label.length + prefixLen)
    };
}
function buildTree(src, keyLength) {
    // Convert map keys
    let converted = new Map();
    for (let k of Array.from(src.keys())){
        const padded = pad(k.toString(2), keyLength);
        converted.set(padded, src.get(k));
    }
    // Calculate root label
    return buildEdge(converted);
}
exports.buildTree = buildTree;
//
// Serialization
//
function writeLabelShort(src, to) {
    // Header
    to.storeBit(0);
    // Unary length
    for(let i = 0; i < src.length; i++){
        to.storeBit(1);
    }
    to.storeBit(0);
    // Value
    if (src.length > 0) {
        to.storeUint(BigInt('0b' + src), src.length);
    }
    return to;
}
exports.writeLabelShort = writeLabelShort;
function labelShortLength(src) {
    return 1 + src.length + 1 + src.length;
}
function writeLabelLong(src, keyLength, to) {
    // Header
    to.storeBit(1);
    to.storeBit(0);
    // Length
    let length = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(src.length, length);
    // Value
    if (src.length > 0) {
        to.storeUint(BigInt('0b' + src), src.length);
    }
    return to;
}
exports.writeLabelLong = writeLabelLong;
function labelLongLength(src, keyLength) {
    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
}
function writeLabelSame(value, length, keyLength, to) {
    // Header
    to.storeBit(1);
    to.storeBit(1);
    // Value
    to.storeBit(value);
    // Length
    let lenLen = Math.ceil(Math.log2(keyLength + 1));
    to.storeUint(length, lenLen);
}
exports.writeLabelSame = writeLabelSame;
function labelSameLength(keyLength) {
    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
}
function isSame(src) {
    if (src.length === 0 || src.length === 1) {
        return true;
    }
    for(let i = 1; i < src.length; i++){
        if (src[i] !== src[0]) {
            return false;
        }
    }
    return true;
}
function detectLabelType(src, keyLength) {
    let kind = 'short';
    let kindLength = labelShortLength(src);
    let longLength = labelLongLength(src, keyLength);
    if (longLength < kindLength) {
        kindLength = longLength;
        kind = 'long';
    }
    if (isSame(src)) {
        let sameLength = labelSameLength(keyLength);
        if (sameLength < kindLength) {
            kindLength = sameLength;
            kind = 'same';
        }
    }
    return kind;
}
exports.detectLabelType = detectLabelType;
function writeLabel(src, keyLength, to) {
    let type = detectLabelType(src, keyLength);
    if (type === 'short') {
        writeLabelShort(src, to);
    } else if (type === 'long') {
        writeLabelLong(src, keyLength, to);
    } else if (type === 'same') {
        writeLabelSame(src[0] === '1', src.length, keyLength, to);
    }
}
function writeNode(src, keyLength, serializer, to) {
    if (src.type === 'leaf') {
        serializer(src.value, to);
    }
    if (src.type === 'fork') {
        const leftCell = (0, Builder_1.beginCell)();
        const rightCell = (0, Builder_1.beginCell)();
        writeEdge(src.left, keyLength - 1, serializer, leftCell);
        writeEdge(src.right, keyLength - 1, serializer, rightCell);
        to.storeRef(leftCell);
        to.storeRef(rightCell);
    }
}
function writeEdge(src, keyLength, serializer, to) {
    writeLabel(src.label, keyLength, to);
    writeNode(src.node, keyLength - src.label.length, serializer, to);
}
function serializeDict(src, keyLength, serializer, to) {
    const tree = buildTree(src, keyLength);
    writeEdge(tree, keyLength, serializer, to);
}
exports.serializeDict = serializeDict;
}),
"[project]/node_modules/@ton/core/dist/dict/utils/internalKeySerializer.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deserializeInternalKey = exports.serializeInternalKey = void 0;
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
const paddedBits_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/utils/paddedBits.js [client] (ecmascript)");
function serializeInternalKey(value) {
    if (typeof value === 'number') {
        if (!Number.isSafeInteger(value)) {
            throw Error('Invalid key type: not a safe integer: ' + value);
        }
        return 'n:' + value.toString(10);
    } else if (typeof value === 'bigint') {
        return 'b:' + value.toString(10);
    } else if (Address_1.Address.isAddress(value)) {
        return 'a:' + value.toString();
    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(value)) {
        return 'f:' + value.toString('hex');
    } else if (BitString_1.BitString.isBitString(value)) {
        return 'B:' + value.toString();
    } else {
        throw Error('Invalid key type');
    }
}
exports.serializeInternalKey = serializeInternalKey;
function deserializeInternalKey(value) {
    let k = value.slice(0, 2);
    let v = value.slice(2);
    if (k === 'n:') {
        return parseInt(v, 10);
    } else if (k === 'b:') {
        return BigInt(v);
    } else if (k === 'a:') {
        return Address_1.Address.parse(v);
    } else if (k === 'f:') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(v, 'hex');
    } else if (k === 'B:') {
        const lastDash = v.slice(-1) == "_";
        const isPadded = lastDash || v.length % 2 != 0;
        if (isPadded) {
            let charLen = lastDash ? v.length - 1 : v.length;
            const padded = v.substr(0, charLen) + "0"; //Padding
            if (!lastDash && (charLen & 1) !== 0) {
                // Four bit nibmle without padding
                return new BitString_1.BitString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(padded, 'hex'), 0, charLen << 2);
            } else {
                return (0, paddedBits_1.paddedBufferToBits)(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(padded, 'hex'));
            }
        } else {
            return new BitString_1.BitString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(v, 'hex'), 0, v.length << 2);
        }
    }
    throw Error('Invalid key type: ' + k);
}
exports.deserializeInternalKey = deserializeInternalKey;
}),
"[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Dictionary = void 0;
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
const generateMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/generateMerkleProof.js [client] (ecmascript)");
const generateMerkleUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/generateMerkleUpdate.js [client] (ecmascript)");
const parseDict_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/parseDict.js [client] (ecmascript)");
const serializeDict_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/serializeDict.js [client] (ecmascript)");
const internalKeySerializer_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/utils/internalKeySerializer.js [client] (ecmascript)");
class Dictionary {
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */ static empty(key, value) {
        if (key && value) {
            return new Dictionary(new Map(), key, value);
        } else {
            return new Dictionary(new Map(), null, null);
        }
    }
    /**
     * Load dictionary from slice
     * @param key key description
     * @param value value description
     * @param src slice
     * @returns Dictionary<K, V>
     */ static load(key, value, sc) {
        let slice;
        if (sc instanceof Cell_1.Cell) {
            if (sc.isExotic) {
                return Dictionary.empty(key, value);
            }
            slice = sc.beginParse();
        } else {
            slice = sc;
        }
        let cell = slice.loadMaybeRef();
        if (cell && !cell.isExotic) {
            return Dictionary.loadDirect(key, value, cell.beginParse());
        } else {
            return Dictionary.empty(key, value);
        }
    }
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */ static loadDirect(key, value, sc) {
        if (!sc) {
            return Dictionary.empty(key, value);
        }
        let slice;
        if (sc instanceof Cell_1.Cell) {
            slice = sc.beginParse();
        } else {
            slice = sc;
        }
        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
        let prepare = new Map();
        for (let [k, v] of values){
            prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
        }
        return new Dictionary(prepare, key, value);
    }
    constructor(values, key, value){
        this._key = key;
        this._value = value;
        this._map = values;
    }
    get size() {
        return this._map.size;
    }
    get(key) {
        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    has(key) {
        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
    }
    set(key, value) {
        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
        return this;
    }
    delete(key) {
        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
        return this._map.delete(k);
    }
    clear() {
        this._map.clear();
    }
    *[Symbol.iterator]() {
        for (const [k, v] of this._map){
            const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
            yield [
                key,
                v
            ];
        }
    }
    keys() {
        return Array.from(this._map.keys()).map((v)=>(0, internalKeySerializer_1.deserializeInternalKey)(v));
    }
    values() {
        return Array.from(this._map.values());
    }
    store(builder, key, value) {
        if (this._map.size === 0) {
            builder.storeBit(0);
        } else {
            // Resolve serializer
            let resolvedKey = this._key;
            if (key !== null && key !== undefined) {
                resolvedKey = key;
            }
            let resolvedValue = this._value;
            if (value !== null && value !== undefined) {
                resolvedValue = value;
            }
            if (!resolvedKey) {
                throw Error('Key serializer is not defined');
            }
            if (!resolvedValue) {
                throw Error('Value serializer is not defined');
            }
            // Prepare map
            let prepared = new Map();
            for (const [k, v] of this._map){
                prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
            }
            // Store
            builder.storeBit(1);
            let dd = (0, Builder_1.beginCell)();
            (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
            builder.storeRef(dd.endCell());
        }
    }
    storeDirect(builder, key, value) {
        if (this._map.size === 0) {
            throw Error('Cannot store empty dictionary directly');
        }
        // Resolve serializer
        let resolvedKey = this._key;
        if (key !== null && key !== undefined) {
            resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== undefined) {
            resolvedValue = value;
        }
        if (!resolvedKey) {
            throw Error('Key serializer is not defined');
        }
        if (!resolvedValue) {
            throw Error('Value serializer is not defined');
        }
        // Prepare map
        let prepared = new Map();
        for (const [k, v] of this._map){
            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
        }
        // Store
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
    }
    /**
     * Generate merkle proof for multiple keys in the dictionary
     * @param keys an array of the keys
     * @returns generated merkle proof cell
     */ generateMerkleProof(keys) {
        return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
    }
    /**
     * Low level method for generating pruned dictionary directly.
     * The result can be used as a part of a bigger merkle proof
     * @param keys an array of the keys
     * @returns cell that contains the pruned dictionary
     */ generateMerkleProofDirect(keys) {
        return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
    }
    generateMerkleUpdate(key, newValue) {
        return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
    }
}
exports.Dictionary = Dictionary;
Dictionary.Keys = {
    /**
     * Standard address key
     * @returns DictionaryKey<Address>
     */ Address: ()=>{
        return createAddressKey();
    },
    /**
     * Create standard big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */ BigInt: (bits)=>{
        return createBigIntKey(bits);
    },
    /**
     * Create integer key
     * @param bits bits of integer
     * @returns DictionaryKey<number>
     */ Int: (bits)=>{
        return createIntKey(bits);
    },
    /**
     * Create standard unsigned big integer key
     * @param bits number of bits
     * @returns DictionaryKey<bigint>
     */ BigUint: (bits)=>{
        return createBigUintKey(bits);
    },
    /**
     * Create standard unsigned integer key
     * @param bits number of bits
     * @returns DictionaryKey<number>
     */ Uint: (bits)=>{
        return createUintKey(bits);
    },
    /**
     * Create standard buffer key
     * @param bytes number of bytes of a buffer
     * @returns DictionaryKey<Buffer>
     */ Buffer: (bytes)=>{
        return createBufferKey(bytes);
    },
    /**
     * Create BitString key
     * @param bits key length
     * @returns DictionaryKey<BitString>
     * Point is that Buffer has to be 8 bit aligned,
     * while key is TVM dictionary doesn't have to be
     * aligned at all.
     */ BitString: (bits)=>{
        return createBitStringKey(bits);
    }
};
Dictionary.Values = {
    /**
     * Create standard integer value
     * @returns DictionaryValue<bigint>
     */ BigInt: (bits)=>{
        return createBigIntValue(bits);
    },
    /**
     * Create standard integer value
     * @returns DictionaryValue<number>
     */ Int: (bits)=>{
        return createIntValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */ BigVarInt: (bits)=>{
        return createBigVarIntValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */ BigUint: (bits)=>{
        return createBigUintValue(bits);
    },
    /**
     * Create standard unsigned integer value
     * @param bits number of bits
     * @returns DictionaryValue<bigint>
     */ Uint: (bits)=>{
        return createUintValue(bits);
    },
    /**
     * Create big var int
     * @param bits nubmer of header bits
     * @returns DictionaryValue<bigint>
     */ BigVarUint: (bits)=>{
        return createBigVarUintValue(bits);
    },
    /**
     * Create standard boolean value
     * @returns DictionaryValue<boolean>
     */ Bool: ()=>{
        return createBooleanValue();
    },
    /**
     * Create standard address value
     * @returns DictionaryValue<Address>
     */ Address: ()=>{
        return createAddressValue();
    },
    /**
     * Create standard cell value
     * @returns DictionaryValue<Cell>
     */ Cell: ()=>{
        return createCellValue();
    },
    /**
     * Create Builder value
     * @param bytes number of bytes of a buffer
     * @returns DictionaryValue<Builder>
     */ Buffer: (bytes)=>{
        return createBufferValue(bytes);
    },
    /**
     * Create BitString value
     * @param requested bit length
     * @returns DictionaryValue<BitString>
     * Point is that Buffer is not applicable
     * when length is not 8 bit alligned.
     */ BitString: (bits)=>{
        return createBitStringValue(bits);
    },
    /**
     * Create dictionary value
     * @param key
     * @param value
     */ Dictionary: (key, value)=>{
        return createDictionaryValue(key, value);
    }
};
//
// Keys and Values
//
function createAddressKey() {
    return {
        bits: 267,
        serialize: (src)=>{
            if (!Address_1.Address.isAddress(src)) {
                throw Error('Key is not an address');
            }
            return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
        },
        parse: (src)=>{
            return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
        }
    };
}
function createBigIntKey(bits) {
    return {
        bits,
        serialize: (src)=>{
            if (typeof src !== 'bigint') {
                throw Error('Key is not a bigint');
            }
            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src)=>{
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
        }
    };
}
function createIntKey(bits) {
    return {
        bits: bits,
        serialize: (src)=>{
            if (typeof src !== 'number') {
                throw Error('Key is not a number');
            }
            if (!Number.isSafeInteger(src)) {
                throw Error('Key is not a safe integer: ' + src);
            }
            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src)=>{
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
        }
    };
}
function createBigUintKey(bits) {
    return {
        bits,
        serialize: (src)=>{
            if (typeof src !== 'bigint') {
                throw Error('Key is not a bigint');
            }
            if (src < 0) {
                throw Error('Key is negative: ' + src);
            }
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src)=>{
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        }
    };
}
function createUintKey(bits) {
    return {
        bits,
        serialize: (src)=>{
            if (typeof src !== 'number') {
                throw Error('Key is not a number');
            }
            if (!Number.isSafeInteger(src)) {
                throw Error('Key is not a safe integer: ' + src);
            }
            if (src < 0) {
                throw Error('Key is negative: ' + src);
            }
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src)=>{
            return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
        }
    };
}
function createBufferKey(bytes) {
    return {
        bits: bytes * 8,
        serialize: (src)=>{
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(src)) {
                throw Error('Key is not a buffer');
            }
            return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
        },
        parse: (src)=>{
            return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
        }
    };
}
function createBitStringKey(bits) {
    return {
        bits,
        serialize: (src)=>{
            if (!BitString_1.BitString.isBitString(src)) throw Error('Key is not a BitString');
            return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src)=>{
            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
        }
    };
}
function createIntValue(bits) {
    return {
        serialize: (src, buidler)=>{
            buidler.storeInt(src, bits);
        },
        parse: (src)=>{
            let value = src.loadInt(bits);
            src.endParse();
            return value;
        }
    };
}
function createBigIntValue(bits) {
    return {
        serialize: (src, buidler)=>{
            buidler.storeInt(src, bits);
        },
        parse: (src)=>{
            let value = src.loadIntBig(bits);
            src.endParse();
            return value;
        }
    };
}
function createBigVarIntValue(bits) {
    return {
        serialize: (src, buidler)=>{
            buidler.storeVarInt(src, bits);
        },
        parse: (src)=>{
            let value = src.loadVarIntBig(bits);
            src.endParse();
            return value;
        }
    };
}
function createBigVarUintValue(bits) {
    return {
        serialize: (src, buidler)=>{
            buidler.storeVarUint(src, bits);
        },
        parse: (src)=>{
            let value = src.loadVarUintBig(bits);
            src.endParse();
            return value;
        }
    };
}
function createUintValue(bits) {
    return {
        serialize: (src, buidler)=>{
            buidler.storeUint(src, bits);
        },
        parse: (src)=>{
            let value = src.loadUint(bits);
            src.endParse();
            return value;
        }
    };
}
function createBigUintValue(bits) {
    return {
        serialize: (src, buidler)=>{
            buidler.storeUint(src, bits);
        },
        parse: (src)=>{
            let value = src.loadUintBig(bits);
            src.endParse();
            return value;
        }
    };
}
function createBooleanValue() {
    return {
        serialize: (src, buidler)=>{
            buidler.storeBit(src);
        },
        parse: (src)=>{
            let value = src.loadBit();
            src.endParse();
            return value;
        }
    };
}
function createAddressValue() {
    return {
        serialize: (src, buidler)=>{
            buidler.storeAddress(src);
        },
        parse: (src)=>{
            let addr = src.loadAddress();
            src.endParse();
            return addr;
        }
    };
}
function createCellValue() {
    return {
        serialize: (src, buidler)=>{
            buidler.storeRef(src);
        },
        parse: (src)=>{
            let value = src.loadRef();
            src.endParse();
            return value;
        }
    };
}
function createDictionaryValue(key, value) {
    return {
        serialize: (src, buidler)=>{
            src.store(buidler);
        },
        parse: (src)=>{
            let dict = Dictionary.load(key, value, src);
            src.endParse();
            return dict;
        }
    };
}
function createBufferValue(size) {
    return {
        serialize: (src, buidler)=>{
            if (src.length !== size) {
                throw Error('Invalid buffer size');
            }
            buidler.storeBuffer(src);
        },
        parse: (src)=>{
            let value = src.loadBuffer(size);
            src.endParse();
            return value;
        }
    };
}
function createBitStringValue(bits) {
    return {
        serialize: (src, builder)=>{
            if (src.length !== bits) {
                throw Error('Invalid BitString size');
            }
            builder.storeBits(src);
        },
        parse: (src)=>{
            let value = src.loadBits(bits);
            src.endParse();
            return value;
        }
    };
}
}),
"[project]/node_modules/@ton/core/dist/boc/utils/strings.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.writeString = exports.stringToCell = exports.readString = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
function readBuffer(slice) {
    // Check consistency
    if (slice.remainingBits % 8 !== 0) {
        throw new Error(`Invalid string length: ${slice.remainingBits}`);
    }
    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
        throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
    }
    // Read string
    let res;
    if (slice.remainingBits === 0) {
        res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0);
    } else {
        res = slice.loadBuffer(slice.remainingBits / 8);
    }
    // Read tail
    if (slice.remainingRefs === 1) {
        res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
            res,
            readBuffer(slice.loadRef().beginParse())
        ]);
    }
    return res;
}
function readString(slice) {
    return readBuffer(slice).toString();
}
exports.readString = readString;
function writeBuffer(src, builder) {
    if (src.length > 0) {
        let bytes = Math.floor(builder.availableBits / 8);
        if (src.length > bytes) {
            let a = src.subarray(0, bytes);
            let t = src.subarray(bytes);
            builder = builder.storeBuffer(a);
            let bb = (0, Builder_1.beginCell)();
            writeBuffer(t, bb);
            builder = builder.storeRef(bb.endCell());
        } else {
            builder = builder.storeBuffer(src);
        }
    }
}
function stringToCell(src) {
    let builder = (0, Builder_1.beginCell)();
    writeBuffer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(src), builder);
    return builder.endCell();
}
exports.stringToCell = stringToCell;
function writeString(src, builder) {
    writeBuffer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(src), builder);
}
exports.writeString = writeString;
}),
"[project]/node_modules/@ton/core/dist/boc/Slice.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Slice = void 0;
const symbol_inspect_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/symbol.inspect/index.js [client] (ecmascript)"));
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const strings_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/utils/strings.js [client] (ecmascript)");
/**
 * Slice is a class that allows to read cell data
 */ class Slice {
    constructor(reader, refs){
        this[_a] = ()=>this.toString();
        this._reader = reader.clone();
        this._refs = [
            ...refs
        ];
        this._refsOffset = 0;
    }
    /**
     * Get remaining bits
     */ get remainingBits() {
        return this._reader.remaining;
    }
    /**
     * Get offset bits
     */ get offsetBits() {
        return this._reader.offset;
    }
    /**
     * Get remaining refs
     */ get remainingRefs() {
        return this._refs.length - this._refsOffset;
    }
    /**
     * Get offset refs
     */ get offsetRefs() {
        return this._refsOffset;
    }
    /**
     * Skip bits
     * @param bits
     */ skip(bits) {
        this._reader.skip(bits);
        return this;
    }
    /**
     * Load a single bit
     * @returns true or false depending on the bit value
     */ loadBit() {
        return this._reader.loadBit();
    }
    /**
     * Preload a signle bit
     * @returns true or false depending on the bit value
     */ preloadBit() {
        return this._reader.preloadBit();
    }
    /**
     * Load a boolean
     * @returns true or false depending on the bit value
     */ loadBoolean() {
        return this.loadBit();
    }
    /**
     * Load maybe boolean
     * @returns true or false depending on the bit value or null
     */ loadMaybeBoolean() {
        if (this.loadBit()) {
            return this.loadBoolean();
        } else {
            return null;
        }
    }
    /**
     * Load bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */ loadBits(bits) {
        return this._reader.loadBits(bits);
    }
    /**
     * Preload bits as a new BitString
     * @param bits number of bits to read
     * @returns new BitString
     */ preloadBits(bits) {
        return this._reader.preloadBits(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */ loadUint(bits) {
        return this._reader.loadUint(bits);
    }
    /**
     * Load uint
     * @param bits number of bits to read
     * @returns uint value
     */ loadUintBig(bits) {
        return this._reader.loadUintBig(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */ preloadUint(bits) {
        return this._reader.preloadUint(bits);
    }
    /**
     * Preload uint
     * @param bits number of bits to read
     * @returns uint value
     */ preloadUintBig(bits) {
        return this._reader.preloadUintBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */ loadMaybeUint(bits) {
        if (this.loadBit()) {
            return this.loadUint(bits);
        } else {
            return null;
        }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */ loadMaybeUintBig(bits) {
        if (this.loadBit()) {
            return this.loadUintBig(bits);
        } else {
            return null;
        }
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */ loadInt(bits) {
        return this._reader.loadInt(bits);
    }
    /**
     * Load int
     * @param bits number of bits to read
     * @returns int value
     */ loadIntBig(bits) {
        return this._reader.loadIntBig(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */ preloadInt(bits) {
        return this._reader.preloadInt(bits);
    }
    /**
     * Preload int
     * @param bits number of bits to read
     * @returns int value
     */ preloadIntBig(bits) {
        return this._reader.preloadIntBig(bits);
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */ loadMaybeInt(bits) {
        if (this.loadBit()) {
            return this.loadInt(bits);
        } else {
            return null;
        }
    }
    /**
     * Load maybe uint
     * @param bits number of bits to read
     * @returns uint value or null
     */ loadMaybeIntBig(bits) {
        if (this.loadBit()) {
            return this.loadIntBig(bits);
        } else {
            return null;
        }
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */ loadVarUint(bits) {
        return this._reader.loadVarUint(bits);
    }
    /**
     * Load varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */ loadVarUintBig(bits) {
        return this._reader.loadVarUintBig(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */ preloadVarUint(bits) {
        return this._reader.preloadVarUint(bits);
    }
    /**
     * Preload varuint
     * @param bits number of bits to read in header
     * @returns varuint value
     */ preloadVarUintBig(bits) {
        return this._reader.preloadVarUintBig(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */ loadVarInt(bits) {
        return this._reader.loadVarInt(bits);
    }
    /**
     * Load varint
     * @param bits number of bits to read in header
     * @returns varint value
     */ loadVarIntBig(bits) {
        return this._reader.loadVarIntBig(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */ preloadVarInt(bits) {
        return this._reader.preloadVarInt(bits);
    }
    /**
     * Preload varint
     * @param bits number of bits to read in header
     * @returns varint value
     */ preloadVarIntBig(bits) {
        return this._reader.preloadVarIntBig(bits);
    }
    /**
     * Load coins
     * @returns coins value
     */ loadCoins() {
        return this._reader.loadCoins();
    }
    /**
     * Preload coins
     * @returns coins value
     */ preloadCoins() {
        return this._reader.preloadCoins();
    }
    /**
     * Load maybe coins
     * @returns coins value or null
     */ loadMaybeCoins() {
        if (this._reader.loadBit()) {
            return this._reader.loadCoins();
        } else {
            return null;
        }
    }
    /**
     * Load internal Address
     * @returns Address
     */ loadAddress() {
        return this._reader.loadAddress();
    }
    /**
     * Load optional internal Address
     * @returns Address or null
     */ loadMaybeAddress() {
        return this._reader.loadMaybeAddress();
    }
    /**
     * Load external address
     * @returns ExternalAddress
     */ loadExternalAddress() {
        return this._reader.loadExternalAddress();
    }
    /**
     * Load optional external address
     * @returns ExternalAddress or null
     */ loadMaybeExternalAddress() {
        return this._reader.loadMaybeExternalAddress();
    }
    /**
     * Load address
     * @returns Address, ExternalAddress or null
     */ loadAddressAny() {
        return this._reader.loadAddressAny();
    }
    /**
     * Load reference
     * @returns Cell
     */ loadRef() {
        if (this._refsOffset >= this._refs.length) {
            throw new Error("No more references");
        }
        return this._refs[this._refsOffset++];
    }
    /**
     * Preload reference
     * @returns Cell
     */ preloadRef() {
        if (this._refsOffset >= this._refs.length) {
            throw new Error("No more references");
        }
        return this._refs[this._refsOffset];
    }
    /**
     * Load optional reference
     * @returns Cell or null
     */ loadMaybeRef() {
        if (this.loadBit()) {
            return this.loadRef();
        } else {
            return null;
        }
    }
    /**
     * Preload optional reference
     * @returns Cell or null
     */ preloadMaybeRef() {
        if (this.preloadBit()) {
            return this.preloadRef();
        } else {
            return null;
        }
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */ loadBuffer(bytes) {
        return this._reader.loadBuffer(bytes);
    }
    /**
     * Load byte buffer
     * @param bytes number of bytes to load
     * @returns Buffer
     */ preloadBuffer(bytes) {
        return this._reader.preloadBuffer(bytes);
    }
    /**
     * Load string tail
     */ loadStringTail() {
        return (0, strings_1.readString)(this);
    }
    /**
     * Load maybe string tail
     * @returns string or null
     */ loadMaybeStringTail() {
        if (this.loadBit()) {
            return (0, strings_1.readString)(this);
        } else {
            return null;
        }
    }
    /**
     * Load string tail from ref
     * @returns string
     */ loadStringRefTail() {
        return (0, strings_1.readString)(this.loadRef().beginParse());
    }
    /**
     * Load maybe string tail from ref
     * @returns string or null
     */ loadMaybeStringRefTail() {
        const ref = this.loadMaybeRef();
        if (ref) {
            return (0, strings_1.readString)(ref.beginParse());
        } else {
            return null;
        }
    }
    /**
     * Loads dictionary
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */ loadDict(key, value) {
        return Dictionary_1.Dictionary.load(key, value, this);
    }
    /**
     * Loads dictionary directly from current slice
     * @param key key description
     * @param value value description
     * @returns Dictionary<K, V>
     */ loadDictDirect(key, value) {
        return Dictionary_1.Dictionary.loadDirect(key, value, this);
    }
    /**
     * Checks if slice is empty
     */ endParse() {
        if (this.remainingBits > 0 || this.remainingRefs > 0) {
            throw new Error("Slice is not empty");
        }
    }
    /**
     * Convert slice to cell
     */ asCell() {
        return (0, Builder_1.beginCell)().storeSlice(this).endCell();
    }
    /**
     *
     * @returns
     */ asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this);
    }
    /**
     * Clone slice
     * @returns cloned slice
     */ clone(fromStart = false) {
        if (fromStart) {
            let reader = this._reader.clone();
            reader.reset();
            return new Slice(reader, this._refs);
        } else {
            let res = new Slice(this._reader, this._refs);
            res._refsOffset = this._refsOffset;
            return res;
        }
    }
    /**
     * Print slice as string by converting it to cell
     * @returns string
     */ toString() {
        return this.asCell().toString();
    }
}
exports.Slice = Slice;
_a = symbol_inspect_1.default;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/exoticLibrary.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.exoticLibrary = void 0;
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
function exoticLibrary(bits, refs) {
    const reader = new BitReader_1.BitReader(bits);
    // type + hash
    const size = 8 + 256;
    if (bits.length !== size) {
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
    }
    // Check type
    let type = reader.loadUint(8);
    if (type !== 2) {
        throw new Error(`Library cell must have type 2, got "${type}"`);
    }
    return {};
}
exports.exoticLibrary = exoticLibrary;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleUpdate.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.exoticMerkleUpdate = void 0;
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
function exoticMerkleUpdate(bits, refs) {
    const reader = new BitReader_1.BitReader(bits);
    // type + hash + hash + depth + depth
    const size = 8 + 2 * (256 + 16);
    if (bits.length !== size) {
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
    }
    if (refs.length !== 2) {
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
    }
    let type = reader.loadUint(8);
    if (type !== 4) {
        throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
    }
    const proofHash1 = reader.loadBuffer(32);
    const proofHash2 = reader.loadBuffer(32);
    const proofDepth1 = reader.loadUint(16);
    const proofDepth2 = reader.loadUint(16);
    if (proofDepth1 !== refs[0].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
    }
    if (!proofHash1.equals(refs[0].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString('hex')}", got "${refs[0].hash(0).toString('hex')}"`);
    }
    if (proofDepth2 !== refs[1].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
    }
    if (!proofHash2.equals(refs[1].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString('hex')}", got "${refs[1].hash(0).toString('hex')}"`);
    }
    return {
        proofDepth1,
        proofDepth2,
        proofHash1,
        proofHash2
    };
}
exports.exoticMerkleUpdate = exoticMerkleUpdate;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/LevelMask.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LevelMask = void 0;
class LevelMask {
    constructor(mask = 0){
        this._mask = 0;
        this._mask = mask;
        this._hashIndex = countSetBits(this._mask);
        this._hashCount = this._hashIndex + 1;
    }
    get value() {
        return this._mask;
    }
    get level() {
        return 32 - Math.clz32(this._mask);
    }
    get hashIndex() {
        return this._hashIndex;
    }
    get hashCount() {
        return this._hashCount;
    }
    apply(level) {
        return new LevelMask(this._mask & (1 << level) - 1);
    }
    isSignificant(level) {
        let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
        return res;
    // bool res = level == 0 | | ( (mask_ >> (level -1)) % 2 != 0);
    }
}
exports.LevelMask = LevelMask;
function countSetBits(n) {
    n = n - (n >> 1 & 0x55555555);
    n = (n & 0x33333333) + (n >> 2 & 0x33333333);
    return (n + (n >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;
}
}),
"[project]/node_modules/@ton/core/dist/boc/cell/exoticPruned.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.exoticPruned = void 0;
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
const LevelMask_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/LevelMask.js [client] (ecmascript)");
function exoticPruned(bits, refs) {
    let reader = new BitReader_1.BitReader(bits);
    // Check type
    let type = reader.loadUint(8);
    if (type !== 1) {
        throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
    }
    // Check refs
    if (refs.length !== 0) {
        throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
    }
    // Resolve cell
    let mask;
    if (bits.length === 280) {
        // Special case for config proof
        // This test proof is generated in the moment of voting for a slashing
        // it seems that tools generate it incorrectly and therefore doesn't have mask in it
        // so we need to hardcode it equal to 1
        mask = new LevelMask_1.LevelMask(1);
    } else {
        // Check level
        mask = new LevelMask_1.LevelMask(reader.loadUint(8));
        if (mask.level < 1 || mask.level > 3) {
            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
        }
        // Read pruned
        const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 /* Hash */  + 16 /* Depth */ );
        if (bits.length !== size) {
            throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
        }
    }
    // Read pruned
    let pruned = [];
    let hashes = [];
    let depths = [];
    for(let i = 0; i < mask.level; i++){
        hashes.push(reader.loadBuffer(32));
    }
    for(let i = 0; i < mask.level; i++){
        depths.push(reader.loadUint(16));
    }
    for(let i = 0; i < mask.level; i++){
        pruned.push({
            depth: depths[i],
            hash: hashes[i]
        });
    }
    return {
        mask: mask.value,
        pruned
    };
}
exports.exoticPruned = exoticPruned;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/resolveExotic.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resolveExotic = void 0;
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
const CellType_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/CellType.js [client] (ecmascript)");
const exoticLibrary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticLibrary.js [client] (ecmascript)");
const exoticMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js [client] (ecmascript)");
const exoticMerkleUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleUpdate.js [client] (ecmascript)");
const exoticPruned_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticPruned.js [client] (ecmascript)");
const LevelMask_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/LevelMask.js [client] (ecmascript)");
function resolvePruned(bits, refs) {
    // Parse pruned cell
    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
    // Calculate parameters
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(pruned.mask);
    for(let i = 0; i < pruned.pruned.length; i++){
        depths.push(pruned.pruned[i].depth);
        hashes.push(pruned.pruned[i].hash);
    }
    return {
        type: CellType_1.CellType.PrunedBranch,
        depths,
        hashes,
        mask
    };
}
function resolveLibrary(bits, refs) {
    // Parse library cell
    let pruned = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
    // Calculate parameters
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask();
    return {
        type: CellType_1.CellType.Library,
        depths,
        hashes,
        mask
    };
}
function resolveMerkleProof(bits, refs) {
    // Parse merkle proof cell
    let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
    // Calculate parameters
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
    return {
        type: CellType_1.CellType.MerkleProof,
        depths,
        hashes,
        mask
    };
}
function resolveMerkleUpdate(bits, refs) {
    // Parse merkle proof cell
    let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
    // Calculate parameters
    let depths = [];
    let hashes = [];
    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
    return {
        type: CellType_1.CellType.MerkleUpdate,
        depths,
        hashes,
        mask
    };
}
function resolveExotic(bits, refs) {
    let reader = new BitReader_1.BitReader(bits);
    let type = reader.preloadUint(8);
    if (type === 1) {
        return resolvePruned(bits, refs);
    }
    if (type === 2) {
        return resolveLibrary(bits, refs);
    }
    if (type === 3) {
        return resolveMerkleProof(bits, refs);
    }
    if (type === 4) {
        return resolveMerkleUpdate(bits, refs);
    }
    throw Error('Invalid exotic cell type: ' + type);
}
exports.resolveExotic = resolveExotic;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/descriptor.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;
const CellType_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/CellType.js [client] (ecmascript)");
const paddedBits_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/utils/paddedBits.js [client] (ecmascript)");
function getRefsDescriptor(refs, levelMask, type) {
    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
}
exports.getRefsDescriptor = getRefsDescriptor;
function getBitsDescriptor(bits) {
    let len = bits.length;
    return Math.ceil(len / 8) + Math.floor(len / 8);
}
exports.getBitsDescriptor = getBitsDescriptor;
function getRepr(originalBits, bits, refs, level, levelMask, type) {
    // Allocate
    const bitsLen = Math.ceil(bits.length / 8);
    const repr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(2 + bitsLen + (2 + 32) * refs.length);
    // Write descriptors
    let reprCursor = 0;
    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
    repr[reprCursor++] = getBitsDescriptor(originalBits);
    // Write bits
    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
    reprCursor += bitsLen;
    // Write refs
    for (const c of refs){
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
            childDepth = c.depth(level + 1);
        } else {
            childDepth = c.depth(level);
        }
        repr[reprCursor++] = Math.floor(childDepth / 256);
        repr[reprCursor++] = childDepth % 256;
    }
    for (const c of refs){
        let childHash;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
            childHash = c.hash(level + 1);
        } else {
            childHash = c.hash(level);
        }
        childHash.copy(repr, reprCursor);
        reprCursor += 32;
    }
    // Result
    return repr;
}
exports.getRepr = getRepr;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/wonderCalculator.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wonderCalculator = void 0;
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
const CellType_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/CellType.js [client] (ecmascript)");
const LevelMask_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/LevelMask.js [client] (ecmascript)");
const exoticPruned_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticPruned.js [client] (ecmascript)");
const exoticMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js [client] (ecmascript)");
const descriptor_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/descriptor.js [client] (ecmascript)");
const crypto_1 = (()=>{
    const e = new Error("Cannot find module '@ton/crypto'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const exoticMerkleUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleUpdate.js [client] (ecmascript)");
const exoticLibrary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticLibrary.js [client] (ecmascript)");
//
// This function replicates unknown logic of resolving cell data
// https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214
//
function wonderCalculator(type, bits, refs) {
    //
    // Resolving level mask
    //
    let levelMask;
    let pruned = null;
    if (type === CellType_1.CellType.Ordinary) {
        let mask = 0;
        for (let r of refs){
            mask = mask | r.mask.value;
        }
        levelMask = new LevelMask_1.LevelMask(mask);
    } else if (type === CellType_1.CellType.PrunedBranch) {
        // Parse pruned
        pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
        // Load level
        levelMask = new LevelMask_1.LevelMask(pruned.mask);
    } else if (type === CellType_1.CellType.MerkleProof) {
        // Parse proof
        let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
        // Load level
        levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
    } else if (type === CellType_1.CellType.MerkleUpdate) {
        // Parse update
        let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
        // Load level
        levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
    } else if (type === CellType_1.CellType.Library) {
        // Parse library
        let loaded = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
        // Load level
        levelMask = new LevelMask_1.LevelMask();
    } else {
        throw new Error("Unsupported exotic type");
    }
    //
    // Calculate hashes and depths
    // NOTE: https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214
    //
    let depths = [];
    let hashes = [];
    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
    let totalHashCount = levelMask.hashCount;
    let hashIOffset = totalHashCount - hashCount;
    for(let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++){
        if (!levelMask.isSignificant(levelI)) {
            continue;
        }
        if (hashI < hashIOffset) {
            hashI++;
            continue;
        }
        //
        // Bits
        //
        let currentBits;
        if (hashI === hashIOffset) {
            if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
                throw Error('Invalid');
            }
            currentBits = bits;
        } else {
            if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
                throw Error('Invalid: ' + levelI + ', ' + type);
            }
            currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
        }
        //
        // Depth
        //
        let currentDepth = 0;
        for (let c of refs){
            let childDepth;
            if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
                childDepth = c.depth(levelI + 1);
            } else {
                childDepth = c.depth(levelI);
            }
            currentDepth = Math.max(currentDepth, childDepth);
        }
        if (refs.length > 0) {
            currentDepth++;
        }
        //
        // Hash
        //
        let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
        let hash = (0, crypto_1.sha256_sync)(repr);
        //
        // Persist next
        //
        let destI = hashI - hashIOffset;
        depths[destI] = currentDepth;
        hashes[destI] = hash;
        //
        // Next
        //
        hashI++;
    }
    //
    // Calculate hash and depth for all levels
    //
    let resolvedHashes = [];
    let resolvedDepths = [];
    if (pruned) {
        for(let i = 0; i < 4; i++){
            const { hashIndex } = levelMask.apply(i);
            const { hashIndex: thisHashIndex } = levelMask;
            if (hashIndex !== thisHashIndex) {
                resolvedHashes.push(pruned.pruned[hashIndex].hash);
                resolvedDepths.push(pruned.pruned[hashIndex].depth);
            } else {
                resolvedHashes.push(hashes[0]);
                resolvedDepths.push(depths[0]);
            }
        }
    } else {
        for(let i = 0; i < 4; i++){
            resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
            resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
        }
    }
    //
    // Result
    //
    return {
        mask: levelMask,
        hashes: resolvedHashes,
        depths: resolvedDepths
    };
}
exports.wonderCalculator = wonderCalculator;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/utils/topologicalSort.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.topologicalSort = void 0;
function topologicalSort(src) {
    let pending = [
        src
    ];
    let allCells = new Map();
    let notPermCells = new Set();
    let sorted = [];
    while(pending.length > 0){
        const cells = [
            ...pending
        ];
        pending = [];
        for (let cell of cells){
            const hash = cell.hash().toString('hex');
            if (allCells.has(hash)) {
                continue;
            }
            notPermCells.add(hash);
            allCells.set(hash, {
                cell: cell,
                refs: cell.refs.map((v)=>v.hash().toString('hex'))
            });
            for (let r of cell.refs){
                pending.push(r);
            }
        }
    }
    let tempMark = new Set();
    function visit(hash) {
        if (!notPermCells.has(hash)) {
            return;
        }
        if (tempMark.has(hash)) {
            throw Error('Not a DAG');
        }
        tempMark.add(hash);
        let refs = allCells.get(hash).refs;
        for(let ci = refs.length - 1; ci >= 0; ci--){
            visit(refs[ci]);
        }
        sorted.push(hash);
        tempMark.delete(hash);
        notPermCells.delete(hash);
    }
    while(notPermCells.size > 0){
        const id = Array.from(notPermCells)[0];
        visit(id);
    }
    let indexes = new Map();
    for(let i = 0; i < sorted.length; i++){
        indexes.set(sorted[sorted.length - i - 1], i);
    }
    let result = [];
    for(let i = sorted.length - 1; i >= 0; i--){
        let ent = sorted[i];
        const rrr = allCells.get(ent);
        result.push({
            cell: rrr.cell,
            refs: rrr.refs.map((v)=>indexes.get(v))
        });
    }
    return result;
}
exports.topologicalSort = topologicalSort;
}),
"[project]/node_modules/@ton/core/dist/utils/bitsForNumber.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bitsForNumber = void 0;
function bitsForNumber(src, mode) {
    let v = BigInt(src);
    // Handle negative values
    if (mode === 'int') {
        // Corner case for zero or -1 value
        if (v === 0n || v === -1n) {
            return 1;
        }
        let v2 = v > 0 ? v : -v;
        return v2.toString(2).length + 1 /* Sign bit */ ;
    } else if (mode === 'uint') {
        if (v < 0) {
            throw Error(`value is negative. Got ${src}`);
        }
        return v.toString(2).length;
    } else {
        throw Error(`invalid mode. Got ${mode}`);
    }
}
exports.bitsForNumber = bitsForNumber;
}),
"[project]/node_modules/@ton/core/dist/utils/crc32c.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crc32c = void 0;
const POLY = 0x82f63b78;
function crc32c(source) {
    let crc = 0 ^ 0xffffffff;
    for(let n = 0; n < source.length; n++){
        crc ^= source[n];
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    crc = crc ^ 0xffffffff;
    // Convert endianness
    let res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(4);
    res.writeInt32LE(crc);
    return res;
}
exports.crc32c = crc32c;
}),
"[project]/node_modules/@ton/core/dist/boc/cell/serialization.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
const Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
const topologicalSort_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/utils/topologicalSort.js [client] (ecmascript)");
const bitsForNumber_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/bitsForNumber.js [client] (ecmascript)");
const BitBuilder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitBuilder.js [client] (ecmascript)");
const descriptor_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/descriptor.js [client] (ecmascript)");
const paddedBits_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/utils/paddedBits.js [client] (ecmascript)");
const crc32c_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/crc32c.js [client] (ecmascript)");
function getHashesCount(levelMask) {
    return getHashesCountFromMask(levelMask & 7);
}
function getHashesCountFromMask(mask) {
    let n = 0;
    for(let i = 0; i < 3; i++){
        n += mask & 1;
        mask = mask >> 1;
    }
    return n + 1; // 1 repr + up to 3 higher hashes
}
function readCell(reader, sizeBytes) {
    // D1
    const d1 = reader.loadUint(8);
    const refsCount = d1 % 8;
    const exotic = !!(d1 & 8);
    // D2
    const d2 = reader.loadUint(8);
    const dataBytesize = Math.ceil(d2 / 2);
    const paddingAdded = !!(d2 % 2);
    const levelMask = d1 >> 5;
    const hasHashes = (d1 & 16) != 0;
    const hash_bytes = 32;
    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
    reader.skip(hashesSize * 8);
    reader.skip(depthSize * 8);
    // Bits
    let bits = BitString_1.BitString.EMPTY;
    if (dataBytesize > 0) {
        if (paddingAdded) {
            bits = reader.loadPaddedBits(dataBytesize * 8);
        } else {
            bits = reader.loadBits(dataBytesize * 8);
        }
    }
    // Refs
    let refs = [];
    for(let i = 0; i < refsCount; i++){
        refs.push(reader.loadUint(sizeBytes * 8));
    }
    // Result
    return {
        bits,
        refs,
        exotic
    };
}
function calcCellSize(cell, sizeBytes) {
    return 2 /* D1+D2 */  + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
}
function parseBoc(src) {
    let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
    let magic = reader.loadUint(32);
    if (magic === 0x68ff65f3) {
        let size = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8); // Must be 1
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        return {
            size,
            offBytes,
            cells,
            roots,
            absent,
            totalCellSize,
            index,
            cellData,
            root: [
                0
            ]
        };
    } else if (magic === 0xacc3a728) {
        let size = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8); // Must be 1
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        let crc32 = reader.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
            throw Error('Invalid CRC32C');
        }
        return {
            size,
            offBytes,
            cells,
            roots,
            absent,
            totalCellSize,
            index,
            cellData,
            root: [
                0
            ]
        };
    } else if (magic === 0xb5ee9c72) {
        let hasIdx = reader.loadUint(1);
        let hasCrc32c = reader.loadUint(1);
        let hasCacheBits = reader.loadUint(1);
        let flags = reader.loadUint(2); // Must be 0
        let size = reader.loadUint(3);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let root = [];
        for(let i = 0; i < roots; i++){
            root.push(reader.loadUint(size * 8));
        }
        let index = null;
        if (hasIdx) {
            index = reader.loadBuffer(cells * offBytes);
        }
        let cellData = reader.loadBuffer(totalCellSize);
        if (hasCrc32c) {
            let crc32 = reader.loadBuffer(4);
            if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
                throw Error('Invalid CRC32C');
            }
        }
        return {
            size,
            offBytes,
            cells,
            roots,
            absent,
            totalCellSize,
            index,
            cellData,
            root
        };
    } else {
        throw Error('Invalid magic');
    }
}
exports.parseBoc = parseBoc;
function deserializeBoc(src) {
    //
    // Parse BOC
    //
    let boc = parseBoc(src);
    let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
    //
    // Load cells
    //
    let cells = [];
    for(let i = 0; i < boc.cells; i++){
        let cll = readCell(reader, boc.size);
        cells.push({
            ...cll,
            result: null
        });
    }
    //
    // Build cells
    //
    for(let i = cells.length - 1; i >= 0; i--){
        if (cells[i].result) {
            throw Error('Impossible');
        }
        let refs = [];
        for (let r of cells[i].refs){
            if (!cells[r].result) {
                throw Error('Invalid BOC file');
            }
            refs.push(cells[r].result);
        }
        cells[i].result = new Cell_1.Cell({
            bits: cells[i].bits,
            refs,
            exotic: cells[i].exotic
        });
    }
    //
    // Load roots
    //
    let roots = [];
    for(let i = 0; i < boc.root.length; i++){
        roots.push(cells[boc.root[i]].result);
    }
    //
    // Return
    //
    return roots;
}
exports.deserializeBoc = deserializeBoc;
function writeCellToBuilder(cell, refs, sizeBytes, to) {
    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
    to.writeUint(d1, 8);
    to.writeUint(d2, 8);
    to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
    for (let r of refs){
        to.writeUint(r, sizeBytes * 8);
    }
}
function serializeBoc(root, opts) {
    // Sort cells
    let allCells = (0, topologicalSort_1.topologicalSort)(root);
    // Calculcate parameters
    let cellsNum = allCells.length;
    let has_idx = opts.idx;
    let has_crc32c = opts.crc32;
    let has_cache_bits = false;
    let flags = 0;
    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, 'uint') / 8), 1);
    let totalCellSize = 0;
    let index = [];
    for (let c of allCells){
        let sz = calcCellSize(c.cell, sizeBytes);
        totalCellSize += sz;
        index.push(totalCellSize);
    }
    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, 'uint') / 8), 1);
    let totalSize = (4 + // magic
    1 + // flags and s_bytes
    1 + // offset_bytes
    3 * sizeBytes + // cells_num, roots, complete
    offsetBytes + // full_size
    1 * sizeBytes + // root_idx
    (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
    // Serialize
    let builder = new BitBuilder_1.BitBuilder(totalSize);
    builder.writeUint(0xb5ee9c72, 32); // Magic
    builder.writeBit(has_idx); // Has index
    builder.writeBit(has_crc32c); // Has crc32c
    builder.writeBit(has_cache_bits); // Has cache bits
    builder.writeUint(flags, 2); // Flags
    builder.writeUint(sizeBytes, 3); // Size bytes
    builder.writeUint(offsetBytes, 8); // Offset bytes
    builder.writeUint(cellsNum, sizeBytes * 8); // Cells num
    builder.writeUint(1, sizeBytes * 8); // Roots num
    builder.writeUint(0, sizeBytes * 8); // Absent num
    builder.writeUint(totalCellSize, offsetBytes * 8); // Total cell size
    builder.writeUint(0, sizeBytes * 8); // Root id == 0
    if (has_idx) {
        for(let i = 0; i < cellsNum; i++){
            builder.writeUint(index[i], offsetBytes * 8);
        }
    }
    for(let i = 0; i < cellsNum; i++){
        writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);
    }
    if (has_crc32c) {
        let crc32 = (0, crc32c_1.crc32c)(builder.buffer()); // builder.buffer() is fast since it doesn't allocate new memory
        builder.writeBuffer(crc32);
    }
    // Sanity Check
    let res = builder.buffer();
    if (res.length !== totalSize / 8) {
        throw Error('Internal error');
    }
    return res;
}
exports.serializeBoc = serializeBoc;
}),
"[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Cell = void 0;
const symbol_inspect_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/symbol.inspect/index.js [client] (ecmascript)"));
const BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
const CellType_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/CellType.js [client] (ecmascript)");
const Slice_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Slice.js [client] (ecmascript)");
const resolveExotic_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/resolveExotic.js [client] (ecmascript)");
const wonderCalculator_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/wonderCalculator.js [client] (ecmascript)");
const serialization_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/serialization.js [client] (ecmascript)");
const BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
/**
 * Cell as described in TVM spec
 */ class Cell {
    /**
     * Deserialize cells from BOC
     * @param src source buffer
     * @returns array of cells
     */ static fromBoc(src) {
        return (0, serialization_1.deserializeBoc)(src);
    }
    /**
     * Helper function that deserializes a single cell from BOC in base64
     * @param src source string
     */ static fromBase64(src) {
        let parsed = Cell.fromBoc(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(src, 'base64'));
        if (parsed.length !== 1) {
            throw new Error("Deserialized more than one cell");
        }
        return parsed[0];
    }
    /**
     * Helper function that deserializes a single cell from BOC in hex
     * @param src source string
     */ static fromHex(src) {
        let parsed = Cell.fromBoc(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(src, 'hex'));
        if (parsed.length !== 1) {
            throw new Error("Deserialized more than one cell");
        }
        return parsed[0];
    }
    constructor(opts){
        // Level and depth information
        this._hashes = [];
        this._depths = [];
        /**
         * Beging cell parsing
         * @returns a new slice
         */ this.beginParse = (allowExotic = false)=>{
            if (this.isExotic && !allowExotic) {
                throw new Error("Exotic cells cannot be parsed");
            }
            return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
        };
        /**
         * Get cell hash
         * @param level level
         * @returns cell hash
         */ this.hash = (level = 3)=>{
            return this._hashes[Math.min(this._hashes.length - 1, level)];
        };
        /**
         * Get cell depth
         * @param level level
         * @returns cell depth
         */ this.depth = (level = 3)=>{
            return this._depths[Math.min(this._depths.length - 1, level)];
        };
        /**
         * Get cell level
         * @returns cell level
         */ this.level = ()=>{
            return this.mask.level;
        };
        /**
         * Checks cell to be euqal to another cell
         * @param other other cell
         * @returns true if cells are equal
         */ this.equals = (other)=>{
            return this.hash().equals(other.hash());
        };
        this[_a] = ()=>this.toString();
        // Resolve bits
        let bits = BitString_1.BitString.EMPTY;
        if (opts && opts.bits) {
            bits = opts.bits;
        }
        // Resolve refs
        let refs = [];
        if (opts && opts.refs) {
            refs = [
                ...opts.refs
            ];
        }
        // Resolve type
        let hashes;
        let depths;
        let mask;
        let type = CellType_1.CellType.Ordinary;
        if (opts && opts.exotic) {
            // Resolve exotic cell
            let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
            // Perform wonders
            let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
            // Copy results
            mask = wonders.mask;
            depths = wonders.depths;
            hashes = wonders.hashes;
            type = resolved.type;
        } else {
            // Check correctness
            if (refs.length > 4) {
                throw new Error("Invalid number of references");
            }
            if (bits.length > 1023) {
                throw new Error(`Bits overflow: ${bits.length} > 1023`);
            }
            // Perform wonders
            let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
            // Copy results
            mask = wonders.mask;
            depths = wonders.depths;
            hashes = wonders.hashes;
            type = CellType_1.CellType.Ordinary;
        }
        // Set fields
        this.type = type;
        this.bits = bits;
        this.refs = refs;
        this.mask = mask;
        this._depths = depths;
        this._hashes = hashes;
        Object.freeze(this);
        Object.freeze(this.refs);
        Object.freeze(this.bits);
        Object.freeze(this.mask);
        Object.freeze(this._depths);
        Object.freeze(this._hashes);
    }
    /**
     * Check if cell is exotic
     */ get isExotic() {
        return this.type !== CellType_1.CellType.Ordinary;
    }
    /**
     * Serializes cell to BOC
     * @param opts options
     */ toBoc(opts) {
        let idx = opts && opts.idx !== null && opts.idx !== undefined ? opts.idx : false;
        let crc32 = opts && opts.crc32 !== null && opts.crc32 !== undefined ? opts.crc32 : true;
        return (0, serialization_1.serializeBoc)(this, {
            idx,
            crc32
        });
    }
    /**
     * Format cell to string
     * @param indent indentation
     * @returns string representation
     */ toString(indent) {
        let id = indent || '';
        let t = 'x';
        if (this.isExotic) {
            if (this.type === CellType_1.CellType.MerkleProof) {
                t = 'p';
            } else if (this.type === CellType_1.CellType.MerkleUpdate) {
                t = 'u';
            } else if (this.type === CellType_1.CellType.PrunedBranch) {
                t = 'p';
            }
        }
        let s = id + (this.isExotic ? t : 'x') + '{' + this.bits.toString() + '}';
        for(let k in this.refs){
            const i = this.refs[k];
            s += '\n' + i.toString(id + ' ');
        }
        return s;
    }
    /**
     * Covnert cell to slice
     * @returns slice
     */ asSlice() {
        return this.beginParse();
    }
    /**
     * Convert cell to a builder that has this cell stored
     * @returns builder
     */ asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
    }
}
exports.Cell = Cell;
_a = symbol_inspect_1.default;
Cell.EMPTY = new Cell();
}),
"[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Builder = exports.beginCell = void 0;
const BitBuilder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitBuilder.js [client] (ecmascript)");
const Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
const strings_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/utils/strings.js [client] (ecmascript)");
/**
 * Start building a cell
 * @returns a new builder
 */ function beginCell() {
    return new Builder();
}
exports.beginCell = beginCell;
/**
 * Builder for Cells
 */ class Builder {
    constructor(){
        this._bits = new BitBuilder_1.BitBuilder();
        this._refs = [];
    }
    /**
     * Bits written so far
     */ get bits() {
        return this._bits.length;
    }
    /**
     * References written so far
     */ get refs() {
        return this._refs.length;
    }
    /**
     * Available bits
     */ get availableBits() {
        return 1023 - this.bits;
    }
    /**
     * Available references
     */ get availableRefs() {
        return 4 - this.refs;
    }
    /**
     * Write a single bit
     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
     * @returns this builder
     */ storeBit(value) {
        this._bits.writeBit(value);
        return this;
    }
    /**
     * Write bits from BitString
     * @param src source bits
     * @returns this builder
     */ storeBits(src) {
        this._bits.writeBits(src);
        return this;
    }
    /**
     * Store Buffer
     * @param src source buffer
     * @param bytes optional number of bytes to write
     * @returns this builder
     */ storeBuffer(src, bytes) {
        if (bytes !== undefined && bytes !== null) {
            if (src.length !== bytes) {
                throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
            }
        }
        this._bits.writeBuffer(src);
        return this;
    }
    /**
     * Store Maybe Buffer
     * @param src source buffer or null
     * @param bytes optional number of bytes to write
     * @returns this builder
     */ storeMaybeBuffer(src, bytes) {
        if (src !== null) {
            this.storeBit(1);
            this.storeBuffer(src, bytes);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store uint value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */ storeUint(value, bits) {
        this._bits.writeUint(value, bits);
        return this;
    }
    /**
     * Store maybe uint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */ storeMaybeUint(value, bits) {
        if (value !== null && value !== undefined) {
            this.storeBit(1);
            this.storeUint(value, bits);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store int value
     * @param value value as bigint or number
     * @param bits number of bits to write
     * @returns this builder
     */ storeInt(value, bits) {
        this._bits.writeInt(value, bits);
        return this;
    }
    /**
     * Store maybe int value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write
     * @returns this builder
     */ storeMaybeInt(value, bits) {
        if (value !== null && value !== undefined) {
            this.storeBit(1);
            this.storeInt(value, bits);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store varuint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */ storeVarUint(value, bits) {
        this._bits.writeVarUint(value, bits);
        return this;
    }
    /**
     * Store maybe varuint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */ storeMaybeVarUint(value, bits) {
        if (value !== null && value !== undefined) {
            this.storeBit(1);
            this.storeVarUint(value, bits);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store varint value
     * @param value value as bigint or number
     * @param bits number of bits to write to header
     * @returns this builder
     */ storeVarInt(value, bits) {
        this._bits.writeVarInt(value, bits);
        return this;
    }
    /**
     * Store maybe varint value
     * @param value value as bigint or number, null or undefined
     * @param bits number of bits to write to header
     * @returns this builder
     */ storeMaybeVarInt(value, bits) {
        if (value !== null && value !== undefined) {
            this.storeBit(1);
            this.storeVarInt(value, bits);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store coins value
     * @param amount amount of coins
     * @returns this builder
     */ storeCoins(amount) {
        this._bits.writeCoins(amount);
        return this;
    }
    /**
     * Store maybe coins value
     * @param amount amount of coins, null or undefined
     * @returns this builder
     */ storeMaybeCoins(amount) {
        if (amount !== null && amount !== undefined) {
            this.storeBit(1);
            this.storeCoins(amount);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store address
     * @param addres address to store
     * @returns this builder
     */ storeAddress(address) {
        this._bits.writeAddress(address);
        return this;
    }
    /**
     * Store reference
     * @param cell cell or builder to store
     * @returns this builder
     */ storeRef(cell) {
        // Check refs
        if (this._refs.length >= 4) {
            throw new Error("Too many references");
        }
        // Store reference
        if (cell instanceof Cell_1.Cell) {
            this._refs.push(cell);
        } else if (cell instanceof Builder) {
            this._refs.push(cell.endCell());
        } else {
            throw new Error("Invalid argument");
        }
        return this;
    }
    /**
     * Store reference if not null
     * @param cell cell or builder to store
     * @returns this builder
     */ storeMaybeRef(cell) {
        if (cell) {
            this.storeBit(1);
            this.storeRef(cell);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store slice it in this builder
     * @param src source slice
     */ storeSlice(src) {
        let c = src.clone();
        if (c.remainingBits > 0) {
            this.storeBits(c.loadBits(c.remainingBits));
        }
        while(c.remainingRefs > 0){
            this.storeRef(c.loadRef());
        }
        return this;
    }
    /**
     * Store slice in this builder if not null
     * @param src source slice
     */ storeMaybeSlice(src) {
        if (src) {
            this.storeBit(1);
            this.storeSlice(src);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store builder
     * @param src builder to store
     * @returns this builder
     */ storeBuilder(src) {
        return this.storeSlice(src.endCell().beginParse());
    }
    /**
     * Store builder if not null
     * @param src builder to store
     * @returns this builder
     */ storeMaybeBuilder(src) {
        if (src) {
            this.storeBit(1);
            this.storeBuilder(src);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store writer or builder
     * @param writer writer or builder to store
     * @returns this builder
     */ storeWritable(writer) {
        if (typeof writer === 'object') {
            writer.writeTo(this);
        } else {
            writer(this);
        }
        return this;
    }
    /**
     * Store writer or builder if not null
     * @param writer writer or builder to store
     * @returns this builder
     */ storeMaybeWritable(writer) {
        if (writer) {
            this.storeBit(1);
            this.storeWritable(writer);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store object in this builder
     * @param writer Writable or writer functuin
     */ store(writer) {
        this.storeWritable(writer);
        return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */ storeStringTail(src) {
        (0, strings_1.writeString)(src, this);
        return this;
    }
    /**
     * Store string tail
     * @param src source string
     * @returns this builder
     */ storeMaybeStringTail(src) {
        if (src !== null && src !== undefined) {
            this.storeBit(1);
            (0, strings_1.writeString)(src, this);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store string tail in ref
     * @param src source string
     * @returns this builder
     */ storeStringRefTail(src) {
        this.storeRef(beginCell().storeStringTail(src));
        return this;
    }
    /**
     * Store maybe string tail in ref
     * @param src source string
     * @returns this builder
     */ storeMaybeStringRefTail(src) {
        if (src !== null && src !== undefined) {
            this.storeBit(1);
            this.storeStringRefTail(src);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store dictionary in this builder
     * @param dict dictionary to store
     * @returns this builder
     */ storeDict(dict, key, value) {
        if (dict) {
            dict.store(this, key, value);
        } else {
            this.storeBit(0);
        }
        return this;
    }
    /**
     * Store dictionary in this builder directly
     * @param dict dictionary to store
     * @returns this builder
     */ storeDictDirect(dict, key, value) {
        dict.storeDirect(this, key, value);
        return this;
    }
    /**
     * Complete cell
     * @param opts options
     * @returns cell
     */ endCell(opts) {
        return new Cell_1.Cell({
            bits: this._bits.build(),
            refs: this._refs,
            exotic: opts?.exotic
        });
    }
    /**
     * Convert to cell
     * @returns cell
     */ asCell() {
        return this.endCell();
    }
    /**
     * Convert to slice
     * @returns slice
     */ asSlice() {
        return this.endCell().beginParse();
    }
}
exports.Builder = Builder;
}),
"[project]/node_modules/@ton/core/dist/types/SimpleLibrary.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SimpleLibraryValue = exports.storeSimpleLibrary = exports.loadSimpleLibrary = void 0;
function loadSimpleLibrary(slice) {
    return {
        public: slice.loadBit(),
        root: slice.loadRef()
    };
}
exports.loadSimpleLibrary = loadSimpleLibrary;
function storeSimpleLibrary(src) {
    return (builder)=>{
        builder.storeBit(src.public);
        builder.storeRef(src.root);
    };
}
exports.storeSimpleLibrary = storeSimpleLibrary;
exports.SimpleLibraryValue = {
    serialize (src, builder) {
        storeSimpleLibrary(src)(builder);
    },
    parse (src) {
        return loadSimpleLibrary(src);
    }
};
}),
"[project]/node_modules/@ton/core/dist/types/TickTock.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTickTock = exports.loadTickTock = void 0;
function loadTickTock(slice) {
    return {
        tick: slice.loadBit(),
        tock: slice.loadBit()
    };
}
exports.loadTickTock = loadTickTock;
function storeTickTock(src) {
    return (builder)=>{
        builder.storeBit(src.tick);
        builder.storeBit(src.tock);
    };
}
exports.storeTickTock = storeTickTock;
}),
"[project]/node_modules/@ton/core/dist/types/StateInit.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeStateInit = exports.loadStateInit = void 0;
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
const SimpleLibrary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/SimpleLibrary.js [client] (ecmascript)");
const TickTock_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TickTock.js [client] (ecmascript)");
;
function loadStateInit(slice) {
    // Split Depth
    let splitDepth;
    if (slice.loadBit()) {
        splitDepth = slice.loadUint(5);
    }
    // TickTock
    let special;
    if (slice.loadBit()) {
        special = (0, TickTock_1.loadTickTock)(slice);
    }
    // Code and Data
    let code = slice.loadMaybeRef();
    let data = slice.loadMaybeRef();
    // Libs
    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    if (libraries.size === 0) {
        libraries = undefined;
    }
    return {
        splitDepth,
        special,
        code,
        data,
        libraries
    };
}
exports.loadStateInit = loadStateInit;
function storeStateInit(src) {
    return (builder)=>{
        if (src.splitDepth !== null && src.splitDepth !== undefined) {
            builder.storeBit(true);
            builder.storeUint(src.splitDepth, 5);
        } else {
            builder.storeBit(false);
        }
        if (src.special !== null && src.special !== undefined) {
            builder.storeBit(true);
            builder.store((0, TickTock_1.storeTickTock)(src.special));
        } else {
            builder.storeBit(false);
        }
        builder.storeMaybeRef(src.code);
        builder.storeMaybeRef(src.data);
        builder.storeDict(src.libraries);
    };
}
exports.storeStateInit = storeStateInit;
}),
"[project]/node_modules/@ton/core/dist/address/contractAddress.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.contractAddress = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const StateInit_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StateInit.js [client] (ecmascript)");
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
function contractAddress(workchain, init) {
    let hash = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(init)).endCell().hash();
    return new Address_1.Address(workchain, hash);
}
exports.contractAddress = contractAddress;
}),
"[project]/node_modules/@ton/core/dist/tuple/tuple.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseTuple = exports.serializeTuple = exports.parseTupleItem = exports.serializeTupleItem = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const INT64_MIN = BigInt('-9223372036854775808');
const INT64_MAX = BigInt('9223372036854775807');
// vm_stk_null#00 = VmStackValue;
// vm_stk_tinyint#01 value:int64 = VmStackValue;
// vm_stk_int#0201_ value:int257 = VmStackValue;
// vm_stk_nan#02ff = VmStackValue;
// vm_stk_cell#03 cell:^Cell = VmStackValue;
//_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }
//   st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;
// vm_stk_slice#04 _:VmCellSlice = VmStackValue;
// vm_stk_builder#05 cell:^Cell = VmStackValue;
// vm_stk_cont#06 cont:VmCont = VmStackValue;
// vm_tupref_nil$_ = VmTupleRef 0;
// vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;
// vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);
// vm_tuple_nil$_ = VmTuple 0;
// vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);
// vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;
function serializeTupleItem(src, builder) {
    if (src.type === 'null') {
        builder.storeUint(0x00, 8);
    } else if (src.type === 'int') {
        if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
            builder.storeUint(0x01, 8);
            builder.storeInt(src.value, 64);
        } else {
            builder.storeUint(0x0100, 15);
            builder.storeInt(src.value, 257);
        }
    } else if (src.type === 'nan') {
        builder.storeInt(0x02ff, 16);
    } else if (src.type === 'cell') {
        builder.storeUint(0x03, 8);
        builder.storeRef(src.cell);
    } else if (src.type === 'slice') {
        builder.storeUint(0x04, 8);
        builder.storeUint(0, 10);
        builder.storeUint(src.cell.bits.length, 10);
        builder.storeUint(0, 3);
        builder.storeUint(src.cell.refs.length, 3);
        builder.storeRef(src.cell);
    } else if (src.type === 'builder') {
        builder.storeUint(0x05, 8);
        builder.storeRef(src.cell);
    } else if (src.type === 'tuple') {
        let head = null;
        let tail = null;
        for(let i = 0; i < src.items.length; i++){
            // Swap
            let s = head;
            head = tail;
            tail = s;
            if (i > 1) {
                head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();
            }
            let bc = (0, Builder_1.beginCell)();
            serializeTupleItem(src.items[i], bc);
            tail = bc.endCell();
        }
        builder.storeUint(0x07, 8);
        builder.storeUint(src.items.length, 16);
        if (head) {
            builder.storeRef(head);
        }
        if (tail) {
            builder.storeRef(tail);
        }
    } else {
        throw Error('Invalid value');
    }
}
exports.serializeTupleItem = serializeTupleItem;
function parseTupleItem(cs) {
    let kind = cs.loadUint(8);
    if (kind === 0) {
        return {
            type: 'null'
        };
    } else if (kind === 1) {
        return {
            type: 'int',
            value: cs.loadIntBig(64)
        };
    } else if (kind === 2) {
        if (cs.loadUint(7) === 0) {
            return {
                type: 'int',
                value: cs.loadIntBig(257)
            };
        } else {
            cs.loadBit(); // must eq 1
            return {
                type: 'nan'
            };
        }
    } else if (kind === 3) {
        return {
            type: 'cell',
            cell: cs.loadRef()
        };
    } else if (kind === 4) {
        let startBits = cs.loadUint(10);
        let endBits = cs.loadUint(10);
        let startRefs = cs.loadUint(3);
        let endRefs = cs.loadUint(3);
        // Copy to new cell
        let rs = cs.loadRef().beginParse();
        rs.skip(startBits);
        let dt = rs.loadBits(endBits - startBits);
        let builder = (0, Builder_1.beginCell)().storeBits(dt);
        // Copy refs if exist
        if (startRefs < endRefs) {
            for(let i = 0; i < startRefs; i++){
                rs.loadRef();
            }
            for(let i = 0; i < endRefs - startRefs; i++){
                builder.storeRef(rs.loadRef());
            }
        }
        return {
            type: 'slice',
            cell: builder.endCell()
        };
    } else if (kind === 5) {
        return {
            type: 'builder',
            cell: cs.loadRef()
        };
    } else if (kind === 7) {
        let length = cs.loadUint(16);
        let items = [];
        if (length > 1) {
            let head = cs.loadRef().beginParse();
            let tail = cs.loadRef().beginParse();
            items.unshift(parseTupleItem(tail));
            for(let i = 0; i < length - 2; i++){
                let ohead = head;
                head = ohead.loadRef().beginParse();
                tail = ohead.loadRef().beginParse();
                items.unshift(parseTupleItem(tail));
            }
            items.unshift(parseTupleItem(head));
        } else if (length === 1) {
            items.push(parseTupleItem(cs.loadRef().beginParse()));
        }
        return {
            type: 'tuple',
            items
        };
    } else {
        throw Error('Unsupported stack item');
    }
}
exports.parseTupleItem = parseTupleItem;
//
// Stack parsing
// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L783
//
// vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;
// vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);
// vm_stk_nil#_ = VmStackList 0;
//
function serializeTupleTail(src, builder) {
    if (src.length > 0) {
        // rest:^(VmStackList n)
        let tail = (0, Builder_1.beginCell)();
        serializeTupleTail(src.slice(0, src.length - 1), tail);
        builder.storeRef(tail.endCell());
        // tos
        serializeTupleItem(src[src.length - 1], builder);
    }
}
function serializeTuple(src) {
    let builder = (0, Builder_1.beginCell)();
    builder.storeUint(src.length, 24);
    let r = [
        ...src
    ];
    serializeTupleTail(r, builder);
    return builder.endCell();
}
exports.serializeTuple = serializeTuple;
function parseTuple(src) {
    let res = [];
    let cs = src.beginParse();
    let size = cs.loadUint(24);
    for(let i = 0; i < size; i++){
        let next = cs.loadRef();
        res.unshift(parseTupleItem(cs));
        cs = next.beginParse();
    }
    return res;
}
exports.parseTuple = parseTuple;
}),
"[project]/node_modules/@ton/core/dist/tuple/reader.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TupleReader = void 0;
class TupleReader {
    constructor(items){
        this.items = [
            ...items
        ];
    }
    get remaining() {
        return this.items.length;
    }
    peek() {
        if (this.items.length === 0) {
            throw Error('EOF');
        }
        return this.items[0];
    }
    pop() {
        if (this.items.length === 0) {
            throw Error('EOF');
        }
        let res = this.items[0];
        this.items.splice(0, 1);
        return res;
    }
    skip(num = 1) {
        for(let i = 0; i < num; i++){
            this.pop();
        }
        return this;
    }
    readBigNumber() {
        let popped = this.pop();
        if (popped.type !== 'int') {
            throw Error('Not a number');
        }
        return popped.value;
    }
    readBigNumberOpt() {
        let popped = this.pop();
        if (popped.type === 'null') {
            return null;
        }
        if (popped.type !== 'int') {
            throw Error('Not a number');
        }
        return popped.value;
    }
    readNumber() {
        return Number(this.readBigNumber());
    }
    readNumberOpt() {
        let r = this.readBigNumberOpt();
        if (r !== null) {
            return Number(r);
        } else {
            return null;
        }
    }
    readBoolean() {
        let res = this.readNumber();
        return res === 0 ? false : true;
    }
    readBooleanOpt() {
        let res = this.readNumberOpt();
        if (res !== null) {
            return res === 0 ? false : true;
        } else {
            return null;
        }
    }
    readAddress() {
        let r = this.readCell().beginParse().loadAddress();
        if (r !== null) {
            return r;
        } else {
            throw Error('Not an address');
        }
    }
    readAddressOpt() {
        let r = this.readCellOpt();
        if (r !== null) {
            return r.beginParse().loadMaybeAddress();
        } else {
            return null;
        }
    }
    readCell() {
        let popped = this.pop();
        if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {
            throw Error('Not a cell: ' + popped.type);
        }
        return popped.cell;
    }
    readCellOpt() {
        let popped = this.pop();
        if (popped.type === 'null') {
            return null;
        }
        if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {
            throw Error('Not a cell');
        }
        return popped.cell;
    }
    readTuple() {
        let popped = this.pop();
        if (popped.type !== 'tuple') {
            throw Error('Not a tuple');
        }
        return new TupleReader(popped.items);
    }
    readTupleOpt() {
        let popped = this.pop();
        if (popped.type === 'null') {
            return null;
        }
        if (popped.type !== 'tuple') {
            throw Error('Not a tuple');
        }
        return new TupleReader(popped.items);
    }
    static readLispList(reader) {
        const result = [];
        let tail = reader;
        while(tail !== null){
            var head = tail.pop();
            if (tail.items.length === 0 || tail.items[0].type !== 'tuple' && tail.items[0].type !== 'null') {
                throw Error('Lisp list consists only from (any, tuple) elements and ends with null');
            }
            tail = tail.readTupleOpt();
            result.push(head);
        }
        return result;
    }
    readLispListDirect() {
        if (this.items.length === 1 && this.items[0].type === 'null') {
            return [];
        }
        return TupleReader.readLispList(this);
    }
    readLispList() {
        return TupleReader.readLispList(this.readTupleOpt());
    }
    readBuffer() {
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
            throw Error('Not a buffer');
        }
        if (s.remainingBits % 8 !== 0) {
            throw Error('Not a buffer');
        }
        return s.loadBuffer(s.remainingBits / 8);
    }
    readBufferOpt() {
        let r = this.readCellOpt();
        if (r !== null) {
            let s = r.beginParse();
            if (s.remainingRefs !== 0 || s.remainingBits % 8 !== 0) {
                throw Error('Not a buffer');
            }
            return s.loadBuffer(s.remainingBits / 8);
        } else {
            return null;
        }
    }
    readString() {
        let s = this.readCell().beginParse();
        return s.loadStringTail();
    }
    readStringOpt() {
        let r = this.readCellOpt();
        if (r !== null) {
            let s = r.beginParse();
            return s.loadStringTail();
        } else {
            return null;
        }
    }
}
exports.TupleReader = TupleReader;
}),
"[project]/node_modules/@ton/core/dist/tuple/builder.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TupleBuilder = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
const Slice_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Slice.js [client] (ecmascript)");
class TupleBuilder {
    constructor(){
        this._tuple = [];
    }
    writeNumber(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            this._tuple.push({
                type: 'int',
                value: BigInt(v)
            });
        }
    }
    writeBoolean(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            this._tuple.push({
                type: 'int',
                value: v ? -1n : 0n
            });
        }
    }
    writeBuffer(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            this._tuple.push({
                type: 'slice',
                cell: (0, Builder_1.beginCell)().storeBuffer(v).endCell()
            });
        }
    }
    writeString(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            this._tuple.push({
                type: 'slice',
                cell: (0, Builder_1.beginCell)().storeStringTail(v).endCell()
            });
        }
    }
    writeCell(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            if (v instanceof Cell_1.Cell) {
                this._tuple.push({
                    type: 'cell',
                    cell: v
                });
            } else if (v instanceof Slice_1.Slice) {
                this._tuple.push({
                    type: 'cell',
                    cell: v.asCell()
                });
            }
        }
    }
    writeSlice(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            if (v instanceof Cell_1.Cell) {
                this._tuple.push({
                    type: 'slice',
                    cell: v
                });
            } else if (v instanceof Slice_1.Slice) {
                this._tuple.push({
                    type: 'slice',
                    cell: v.asCell()
                });
            }
        }
    }
    writeBuilder(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            if (v instanceof Cell_1.Cell) {
                this._tuple.push({
                    type: 'builder',
                    cell: v
                });
            } else if (v instanceof Slice_1.Slice) {
                this._tuple.push({
                    type: 'builder',
                    cell: v.asCell()
                });
            }
        }
    }
    writeTuple(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            this._tuple.push({
                type: 'tuple',
                items: v
            });
        }
    }
    writeAddress(v) {
        if (v === null || v === undefined) {
            this._tuple.push({
                type: 'null'
            });
        } else {
            this._tuple.push({
                type: 'slice',
                cell: (0, Builder_1.beginCell)().storeAddress(v).endCell()
            });
        }
    }
    build() {
        return [
            ...this._tuple
        ];
    }
}
exports.TupleBuilder = TupleBuilder;
}),
"[project]/node_modules/@ton/core/dist/utils/convert.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromNano = exports.toNano = void 0;
function toNano(src) {
    if (typeof src === 'bigint') {
        return src * 1000000000n;
    } else {
        if (typeof src === 'number') {
            if (!Number.isFinite(src)) {
                throw Error('Invalid number');
            }
            if (Math.log10(src) <= 6) {
                src = src.toLocaleString('en', {
                    minimumFractionDigits: 9,
                    useGrouping: false
                });
            } else if (src - Math.trunc(src) === 0) {
                src = src.toLocaleString('en', {
                    maximumFractionDigits: 0,
                    useGrouping: false
                });
            } else {
                throw Error('Not enough precision for a number value. Use string value instead');
            }
        }
        // Check sign
        let neg = false;
        while(src.startsWith('-')){
            neg = !neg;
            src = src.slice(1);
        }
        // Split string
        if (src === '.') {
            throw Error('Invalid number');
        }
        let parts = src.split('.');
        if (parts.length > 2) {
            throw Error('Invalid number');
        }
        // Prepare parts
        let whole = parts[0];
        let frac = parts[1];
        if (!whole) {
            whole = '0';
        }
        if (!frac) {
            frac = '0';
        }
        if (frac.length > 9) {
            throw Error('Invalid number');
        }
        while(frac.length < 9){
            frac += '0';
        }
        // Convert
        let r = BigInt(whole) * 1000000000n + BigInt(frac);
        if (neg) {
            r = -r;
        }
        return r;
    }
}
exports.toNano = toNano;
function fromNano(src) {
    let v = BigInt(src);
    let neg = false;
    if (v < 0) {
        neg = true;
        v = -v;
    }
    // Convert fraction
    let frac = v % 1000000000n;
    let facStr = frac.toString();
    while(facStr.length < 9){
        facStr = '0' + facStr;
    }
    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    // Convert whole
    let whole = v / 1000000000n;
    let wholeStr = whole.toString();
    // Value
    let value = `${wholeStr}${facStr === '0' ? '' : `.${facStr}`}`;
    if (neg) {
        value = '-' + value;
    }
    return value;
}
exports.fromNano = fromNano;
}),
"[project]/node_modules/@ton/core/dist/types/ExtraCurrency.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.packExtraCurrencyCell = exports.packExtraCurrencyDict = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
function loadExtraCurrency(data) {
    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
    let ecMap = {};
    for (let [k, v] of ecDict){
        ecMap[k] = v;
    }
    return ecMap;
}
exports.loadExtraCurrency = loadExtraCurrency;
function loadMaybeExtraCurrency(data) {
    const ecData = data.loadMaybeRef();
    return ecData === null ? ecData : loadExtraCurrency(ecData);
}
exports.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
function storeExtraCurrency(extracurrency) {
    return (builder)=>{
        builder.storeDict(packExtraCurrencyDict(extracurrency));
    };
}
exports.storeExtraCurrency = storeExtraCurrency;
function packExtraCurrencyDict(extracurrency) {
    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
    Object.entries(extracurrency).map(([k, v])=>resEc.set(Number(k), v));
    return resEc;
}
exports.packExtraCurrencyDict = packExtraCurrencyDict;
function packExtraCurrencyCell(extracurrency) {
    return (0, Builder_1.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
}
exports.packExtraCurrencyCell = packExtraCurrencyCell;
}),
"[project]/node_modules/@ton/core/dist/types/_helpers.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.comment = exports.external = exports.internal = void 0;
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
const Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const convert_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/convert.js [client] (ecmascript)");
const ExtraCurrency_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ExtraCurrency.js [client] (ecmascript)");
function internal(src) {
    // Resolve bounce
    let bounce = true;
    if (src.bounce !== null && src.bounce !== undefined) {
        bounce = src.bounce;
    }
    // Resolve address
    let to;
    if (typeof src.to === 'string') {
        to = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
    } else {
        throw new Error(`Invalid address ${src.to}`);
    }
    // Resolve value
    let value;
    if (typeof src.value === 'string') {
        value = (0, convert_1.toNano)(src.value);
    } else {
        value = src.value;
    }
    let other;
    if (src.extracurrency) {
        // Resolve value
        other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src.extracurrency);
    }
    // Resolve body
    let body = Cell_1.Cell.EMPTY;
    if (typeof src.body === 'string') {
        body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
    } else if (src.body) {
        body = src.body;
    }
    // Create message
    return {
        info: {
            type: 'internal',
            dest: to,
            value: {
                coins: value,
                other
            },
            bounce,
            ihrDisabled: true,
            bounced: false,
            ihrFee: 0n,
            forwardFee: 0n,
            createdAt: 0,
            createdLt: 0n
        },
        init: src.init ?? undefined,
        body: body
    };
}
exports.internal = internal;
function external(src) {
    // Resolve address
    let to;
    if (typeof src.to === 'string') {
        to = Address_1.Address.parse(src.to);
    } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
    } else {
        throw new Error(`Invalid address ${src.to}`);
    }
    return {
        info: {
            type: 'external-in',
            dest: to,
            importFee: 0n
        },
        init: src.init ?? undefined,
        body: src.body || Cell_1.Cell.EMPTY
    };
}
exports.external = external;
function comment(src) {
    return (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
}
exports.comment = comment;
}),
"[project]/node_modules/@ton/core/dist/types/AccountState.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeAccountState = exports.loadAccountState = void 0;
const StateInit_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StateInit.js [client] (ecmascript)");
function loadAccountState(cs) {
    if (cs.loadBit()) {
        return {
            type: 'active',
            state: (0, StateInit_1.loadStateInit)(cs)
        };
    } else if (cs.loadBit()) {
        return {
            type: 'frozen',
            stateHash: cs.loadUintBig(256)
        };
    } else {
        return {
            type: 'uninit'
        };
    }
}
exports.loadAccountState = loadAccountState;
function storeAccountState(src) {
    return (builder)=>{
        if (src.type === 'active') {
            builder.storeBit(true);
            builder.store((0, StateInit_1.storeStateInit)(src.state));
        } else if (src.type === 'frozen') {
            builder.storeBit(false);
            builder.storeBit(true);
            builder.storeUint(src.stateHash, 256);
        } else if (src.type === 'uninit') {
            builder.storeBit(false);
            builder.storeBit(false);
        }
    };
}
exports.storeAccountState = storeAccountState;
}),
"[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeCurrencyCollection = exports.loadCurrencyCollection = void 0;
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
;
function loadCurrencyCollection(slice) {
    const coins = slice.loadCoins();
    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5 /* log2(32) */ ));
    if (other.size === 0) {
        return {
            coins
        };
    } else {
        return {
            other,
            coins
        };
    }
}
exports.loadCurrencyCollection = loadCurrencyCollection;
function storeCurrencyCollection(collection) {
    return (builder)=>{
        builder.storeCoins(collection.coins);
        if (collection.other) {
            builder.storeDict(collection.other);
        } else {
            builder.storeBit(0);
        }
    };
}
exports.storeCurrencyCollection = storeCurrencyCollection;
}),
"[project]/node_modules/@ton/core/dist/types/AccountStorage.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeAccountStorage = exports.loadAccountStorage = void 0;
const AccountState_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountState.js [client] (ecmascript)");
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
function loadAccountStorage(slice) {
    return {
        lastTransLt: slice.loadUintBig(64),
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
        state: (0, AccountState_1.loadAccountState)(slice)
    };
}
exports.loadAccountStorage = loadAccountStorage;
function storeAccountStorage(src) {
    return (builder)=>{
        builder.storeUint(src.lastTransLt, 64);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
        builder.store((0, AccountState_1.storeAccountState)(src.state));
    };
}
exports.storeAccountStorage = storeAccountStorage;
}),
"[project]/node_modules/@ton/core/dist/types/StorageExtraInfo.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeStorageExtraInfo = exports.loadStorageExtraInfo = void 0;
function loadStorageExtraInfo(slice) {
    let header = slice.loadUint(3);
    if (header === 0) {
        return null;
    }
    if (header === 1) {
        return {
            dictHash: slice.loadUintBig(256)
        };
    }
    throw new Error(`Invalid storage extra info header: ${header}`);
}
exports.loadStorageExtraInfo = loadStorageExtraInfo;
function storeStorageExtraInfo(src) {
    return (builder)=>{
        if (src === null || typeof src === 'undefined') {
            builder.storeUint(0, 3);
        } else {
            builder.storeUint(1, 3);
            builder.storeUint(src.dictHash, 256);
        }
    };
}
exports.storeStorageExtraInfo = storeStorageExtraInfo;
}),
"[project]/node_modules/@ton/core/dist/types/StorageUsed.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeStorageUsed = exports.loadStorageUsed = void 0;
function loadStorageUsed(cs) {
    return {
        cells: cs.loadVarUintBig(3),
        bits: cs.loadVarUintBig(3)
    };
}
exports.loadStorageUsed = loadStorageUsed;
function storeStorageUsed(src) {
    return (builder)=>{
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
    };
}
exports.storeStorageUsed = storeStorageUsed;
}),
"[project]/node_modules/@ton/core/dist/types/StorageInfo.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeStorageInfo = exports.loadStorageInfo = void 0;
const StorageExtraInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageExtraInfo.js [client] (ecmascript)");
const StorageUsed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageUsed.js [client] (ecmascript)");
function loadStorageInfo(slice) {
    return {
        used: (0, StorageUsed_1.loadStorageUsed)(slice),
        storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
        lastPaid: slice.loadUint(32),
        duePayment: slice.loadMaybeCoins()
    };
}
exports.loadStorageInfo = loadStorageInfo;
function storeStorageInfo(src) {
    return (builder)=>{
        builder.store((0, StorageUsed_1.storeStorageUsed)(src.used));
        builder.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src.storageExtra));
        builder.storeUint(src.lastPaid, 32);
        builder.storeMaybeCoins(src.duePayment);
    };
}
exports.storeStorageInfo = storeStorageInfo;
}),
"[project]/node_modules/@ton/core/dist/types/Account.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeAccount = exports.loadAccount = void 0;
const AccountStorage_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStorage.js [client] (ecmascript)");
const StorageInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageInfo.js [client] (ecmascript)");
function loadAccount(slice) {
    return {
        addr: slice.loadAddress(),
        storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
        storage: (0, AccountStorage_1.loadAccountStorage)(slice)
    };
}
exports.loadAccount = loadAccount;
function storeAccount(src) {
    return (builder)=>{
        builder.storeAddress(src.addr);
        builder.store((0, StorageInfo_1.storeStorageInfo)(src.storageStats));
        builder.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
    };
}
exports.storeAccount = storeAccount;
}),
"[project]/node_modules/@ton/core/dist/types/AccountStatus.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeAccountStatus = exports.loadAccountStatus = void 0;
/**
 * Load account state from slice
 * @param slice
 * @returns AccountState
 */ function loadAccountStatus(slice) {
    const status = slice.loadUint(2);
    if (status === 0x00) {
        return 'uninitialized';
    }
    if (status === 0x01) {
        return 'frozen';
    }
    if (status === 0x02) {
        return 'active';
    }
    if (status === 0x03) {
        return 'non-existing';
    }
    throw Error('Invalid data');
}
exports.loadAccountStatus = loadAccountStatus;
/**
 * Store account state to builder
 * @param src account state
 * @param builder buidler
 */ function storeAccountStatus(src) {
    return (builder)=>{
        if (src === 'uninitialized') {
            builder.storeUint(0x00, 2);
        } else if (src === 'frozen') {
            builder.storeUint(0x01, 2);
        } else if (src === 'active') {
            builder.storeUint(0x02, 2);
        } else if (src === 'non-existing') {
            builder.storeUint(0x03, 2);
        } else {
            throw Error('Invalid data');
        }
        return builder;
    };
}
exports.storeAccountStatus = storeAccountStatus;
}),
"[project]/node_modules/@ton/core/dist/types/AccountStatusChange.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeAccountStatusChange = exports.loadAccountStatusChange = void 0;
function loadAccountStatusChange(slice) {
    if (!slice.loadBit()) {
        return 'unchanged';
    }
    if (slice.loadBit()) {
        return 'deleted';
    } else {
        return 'frozen';
    }
}
exports.loadAccountStatusChange = loadAccountStatusChange;
function storeAccountStatusChange(src) {
    return (builder)=>{
        if (src == 'unchanged') {
            builder.storeBit(0);
        } else if (src === 'frozen') {
            builder.storeBit(1);
            builder.storeBit(0);
        } else if (src === 'deleted') {
            builder.storeBit(1);
            builder.storeBit(1);
        } else {
            throw Error('Invalid account status change');
        }
    };
}
exports.storeAccountStatusChange = storeAccountStatusChange;
}),
"[project]/node_modules/@ton/core/dist/types/CommonMessageInfoRelaxed.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = void 0;
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
function loadCommonMessageInfoRelaxed(slice) {
    // Internal message
    if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src = slice.loadMaybeAddress();
        const dest = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt = slice.loadUintBig(64);
        const createdAt = slice.loadUint(32);
        return {
            type: 'internal',
            ihrDisabled,
            bounce,
            bounced,
            src,
            dest,
            value,
            ihrFee,
            forwardFee,
            createdLt,
            createdAt
        };
    }
    // External In mesage
    if (!slice.loadBit()) {
        throw Error('External In message is not possible for CommonMessageInfoRelaxed');
    }
    // External Out message
    const src = slice.loadMaybeAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
        type: 'external-out',
        src,
        dest,
        createdLt,
        createdAt
    };
}
exports.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
function storeCommonMessageInfoRelaxed(source) {
    return (builder)=>{
        if (source.type === 'internal') {
            builder.storeBit(0);
            builder.storeBit(source.ihrDisabled);
            builder.storeBit(source.bounce);
            builder.storeBit(source.bounced);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
            builder.storeCoins(source.ihrFee);
            builder.storeCoins(source.forwardFee);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
        } else if (source.type === 'external-out') {
            builder.storeBit(1);
            builder.storeBit(1);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
        } else {
            throw new Error('Unknown CommonMessageInfo type');
        }
    };
}
exports.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
}),
"[project]/node_modules/@ton/core/dist/types/MessageRelaxed.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeMessageRelaxed = exports.loadMessageRelaxed = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const CommonMessageInfoRelaxed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CommonMessageInfoRelaxed.js [client] (ecmascript)");
const StateInit_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StateInit.js [client] (ecmascript)");
function loadMessageRelaxed(slice) {
    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
    let init = null;
    if (slice.loadBit()) {
        if (!slice.loadBit()) {
            init = (0, StateInit_1.loadStateInit)(slice);
        } else {
            init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
        info,
        init,
        body
    };
}
exports.loadMessageRelaxed = loadMessageRelaxed;
function storeMessageRelaxed(message, opts) {
    return (builder)=>{
        // Store CommonMsgInfo
        builder.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
        // Store init
        if (message.init) {
            builder.storeBit(true);
            let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
            // Check if ref is needed
            let needRef = false;
            if (opts && opts.forceRef) {
                needRef = true;
            } else {
                if (builder.availableBits - 2 /* At least on byte for ref flag */  >= initCell.bits) {
                    needRef = false;
                } else {
                    needRef = true;
                }
            }
            // Store ref
            if (needRef) {
                builder.storeBit(true);
                builder.storeRef(initCell);
            } else {
                builder.storeBit(false);
                builder.storeBuilder(initCell);
            }
        } else {
            builder.storeBit(false);
        }
        // Store body
        let needRef = false;
        if (opts && opts.forceRef) {
            needRef = true;
        } else {
            /*
             1. If at least one bit for ref flag
             2. If enough space for refs
             3. If not exotic
            */ if (builder.availableBits - 1 >= message.body.bits.length && builder.refs + message.body.refs.length <= 4 && !message.body.isExotic) {
                needRef = false;
            } else {
                needRef = true;
            }
        }
        if (needRef) {
            builder.storeBit(true);
            builder.storeRef(message.body);
        } else {
            builder.storeBit(false);
            builder.storeBuilder(message.body.asBuilder());
        }
    };
}
exports.storeMessageRelaxed = storeMessageRelaxed;
}),
"[project]/node_modules/@ton/core/dist/types/LibRef.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeLibRef = exports.loadLibRef = void 0;
function loadLibRef(slice) {
    const type = slice.loadUint(1);
    if (type === 0) {
        return {
            type: 'hash',
            libHash: slice.loadBuffer(32)
        };
    } else {
        return {
            type: 'ref',
            library: slice.loadRef()
        };
    }
}
exports.loadLibRef = loadLibRef;
function storeLibRef(src) {
    return (builder)=>{
        if (src.type === 'hash') {
            builder.storeUint(0, 1);
            builder.storeBuffer(src.libHash);
        } else {
            builder.storeUint(1, 1);
            builder.storeRef(src.library);
        }
    };
}
exports.storeLibRef = storeLibRef;
}),
"[project]/node_modules/@ton/core/dist/types/OutList.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadOutList = exports.storeOutList = exports.loadOutAction = exports.storeOutAction = void 0;
const MessageRelaxed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/MessageRelaxed.js [client] (ecmascript)");
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
const LibRef_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/LibRef.js [client] (ecmascript)");
function storeOutAction(action) {
    switch(action.type){
        case 'sendMsg':
            return storeOutActionSendMsg(action);
        case 'setCode':
            return storeOutActionSetCode(action);
        case 'reserve':
            return storeOutActionReserve(action);
        case 'changeLibrary':
            return storeOutActionChangeLibrary(action);
        default:
            throw new Error(`Unknown action type ${action.type}`);
    }
}
exports.storeOutAction = storeOutAction;
/*
action_send_msg#0ec3c86d mode:(## 8)
  out_msg:^(MessageRelaxed Any) = OutAction;
*/ const outActionSendMsgTag = 0x0ec3c86d;
function storeOutActionSendMsg(action) {
    return (builder)=>{
        builder.storeUint(outActionSendMsgTag, 32).storeUint(action.mode, 8).storeRef((0, Builder_1.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
    };
}
/*
action_set_code#ad4de08e new_code:^Cell = OutAction;
 */ const outActionSetCodeTag = 0xad4de08e;
function storeOutActionSetCode(action) {
    return (builder)=>{
        builder.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
    };
}
/*
action_reserve_currency#36e6b809 mode:(## 8)
  currency:CurrencyCollection = OutAction;
 */ const outActionReserveTag = 0x36e6b809;
function storeOutActionReserve(action) {
    return (builder)=>{
        builder.storeUint(outActionReserveTag, 32).storeUint(action.mode, 8).store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
    };
}
/*
action_change_library#26fa1dd4 mode:(## 7)
  libref:LibRef = OutAction;
 */ const outActionChangeLibraryTag = 0x26fa1dd4;
function storeOutActionChangeLibrary(action) {
    return (builder)=>{
        builder.storeUint(outActionChangeLibraryTag, 32).storeUint(action.mode, 7).store((0, LibRef_1.storeLibRef)(action.libRef));
    };
}
function loadOutAction(slice) {
    const tag = slice.loadUint(32);
    if (tag === outActionSendMsgTag) {
        const mode = slice.loadUint(8);
        const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
        return {
            type: 'sendMsg',
            mode,
            outMsg
        };
    }
    if (tag === outActionSetCodeTag) {
        const newCode = slice.loadRef();
        return {
            type: 'setCode',
            newCode
        };
    }
    if (tag === outActionReserveTag) {
        const mode = slice.loadUint(8);
        const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        return {
            type: 'reserve',
            mode,
            currency
        };
    }
    if (tag === outActionChangeLibraryTag) {
        const mode = slice.loadUint(7);
        const libRef = (0, LibRef_1.loadLibRef)(slice);
        return {
            type: 'changeLibrary',
            mode,
            libRef
        };
    }
    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
}
exports.loadOutAction = loadOutAction;
/*
out_list_empty$_ = OutList 0;
out_list$_ {n:#} prev:^(OutList n) action:OutAction
  = OutList (n + 1);
 */ function storeOutList(actions) {
    const cell = actions.reduce((cell, action)=>(0, Builder_1.beginCell)().storeRef(cell).store(storeOutAction(action)).endCell(), (0, Builder_1.beginCell)().endCell());
    return (builder)=>{
        builder.storeSlice(cell.beginParse());
    };
}
exports.storeOutList = storeOutList;
function loadOutList(slice) {
    const actions = [];
    while(slice.remainingRefs){
        const nextCell = slice.loadRef();
        actions.push(loadOutAction(slice));
        slice = nextCell.beginParse();
    }
    return actions.reverse();
}
exports.loadOutList = loadOutList;
}),
"[project]/node_modules/@ton/core/dist/types/CommonMessageInfo.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = void 0;
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
function loadCommonMessageInfo(slice) {
    // Internal message
    if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src = slice.loadAddress();
        const dest = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt = slice.loadUintBig(64);
        const createdAt = slice.loadUint(32);
        return {
            type: 'internal',
            ihrDisabled,
            bounce,
            bounced,
            src,
            dest,
            value,
            ihrFee,
            forwardFee,
            createdLt,
            createdAt
        };
    }
    // External In mesage
    if (!slice.loadBit()) {
        const src = slice.loadMaybeExternalAddress();
        const dest = slice.loadAddress();
        const importFee = slice.loadCoins();
        return {
            type: 'external-in',
            src,
            dest,
            importFee
        };
    }
    // External Out message
    const src = slice.loadAddress();
    const dest = slice.loadMaybeExternalAddress();
    const createdLt = slice.loadUintBig(64);
    const createdAt = slice.loadUint(32);
    return {
        type: 'external-out',
        src,
        dest,
        createdLt,
        createdAt
    };
}
exports.loadCommonMessageInfo = loadCommonMessageInfo;
function storeCommonMessageInfo(source) {
    return (builder)=>{
        if (source.type === 'internal') {
            builder.storeBit(0);
            builder.storeBit(source.ihrDisabled);
            builder.storeBit(source.bounce);
            builder.storeBit(source.bounced);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
            builder.storeCoins(source.ihrFee);
            builder.storeCoins(source.forwardFee);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
        } else if (source.type === 'external-in') {
            builder.storeBit(1);
            builder.storeBit(0);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.storeCoins(source.importFee);
        } else if (source.type === 'external-out') {
            builder.storeBit(1);
            builder.storeBit(1);
            builder.storeAddress(source.src);
            builder.storeAddress(source.dest);
            builder.storeUint(source.createdLt, 64);
            builder.storeUint(source.createdAt, 32);
        } else {
            throw new Error('Unknown CommonMessageInfo type');
        }
    };
}
exports.storeCommonMessageInfo = storeCommonMessageInfo;
}),
"[project]/node_modules/@ton/core/dist/types/ComputeSkipReason.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeComputeSkipReason = exports.loadComputeSkipReason = void 0;
function loadComputeSkipReason(slice) {
    let reason = slice.loadUint(2);
    if (reason === 0x00) {
        return 'no-state';
    } else if (reason === 0x01) {
        return 'bad-state';
    } else if (reason === 0x02) {
        return 'no-gas';
    }
    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
}
exports.loadComputeSkipReason = loadComputeSkipReason;
function storeComputeSkipReason(src) {
    return (builder)=>{
        if (src === 'no-state') {
            builder.storeUint(0x00, 2);
        } else if (src === 'bad-state') {
            builder.storeUint(0x01, 2);
        } else if (src === 'no-gas') {
            builder.storeUint(0x02, 2);
        } else {
            throw new Error(`Unknown ComputeSkipReason: ${src}`);
        }
    };
}
exports.storeComputeSkipReason = storeComputeSkipReason;
}),
"[project]/node_modules/@ton/core/dist/types/DepthBalanceInfo.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = void 0;
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
function loadDepthBalanceInfo(slice) {
    let splitDepth = slice.loadUint(5);
    return {
        splitDepth,
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
    };
}
exports.loadDepthBalanceInfo = loadDepthBalanceInfo;
function storeDepthBalanceInfo(src) {
    return (builder)=>{
        builder.storeUint(src.splitDepth, 5);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
    };
}
exports.storeDepthBalanceInfo = storeDepthBalanceInfo;
}),
"[project]/node_modules/@ton/core/dist/types/HashUpdate.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeHashUpdate = exports.loadHashUpdate = void 0;
function loadHashUpdate(slice) {
    if (slice.loadUint(8) !== 0x72) {
        throw Error('Invalid data');
    }
    const oldHash = slice.loadBuffer(32);
    const newHash = slice.loadBuffer(32);
    return {
        oldHash,
        newHash
    };
}
exports.loadHashUpdate = loadHashUpdate;
function storeHashUpdate(src) {
    return (builder)=>{
        builder.storeUint(0x72, 8);
        builder.storeBuffer(src.oldHash);
        builder.storeBuffer(src.newHash);
    };
}
exports.storeHashUpdate = storeHashUpdate;
}),
"[project]/node_modules/@ton/core/dist/types/MasterchainStateExtra.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadMasterchainStateExtra = void 0;
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
function loadMasterchainStateExtra(cs) {
    // Check magic
    if (cs.loadUint(16) !== 0xcc26) {
        throw Error('Invalid data');
    }
    // Skip shard_hashes
    if (cs.loadBit()) {
        cs.loadRef();
    }
    // Read config
    let configAddress = cs.loadUintBig(256);
    let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
    // Rad global balance
    const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
    return {
        config,
        configAddress,
        globalBalance
    };
}
exports.loadMasterchainStateExtra = loadMasterchainStateExtra;
}),
"[project]/node_modules/@ton/core/dist/types/Message.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageValue = exports.storeMessage = exports.loadMessage = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const CommonMessageInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CommonMessageInfo.js [client] (ecmascript)");
const StateInit_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StateInit.js [client] (ecmascript)");
function loadMessage(slice) {
    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
    let init = null;
    if (slice.loadBit()) {
        if (!slice.loadBit()) {
            init = (0, StateInit_1.loadStateInit)(slice);
        } else {
            init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
    }
    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
    return {
        info,
        init,
        body
    };
}
exports.loadMessage = loadMessage;
function storeMessage(message, opts) {
    return (builder)=>{
        // Store CommonMsgInfo
        builder.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
        // Store init
        if (message.init) {
            builder.storeBit(true);
            let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
            // Check if need to store it in ref
            let needRef = false;
            if (opts && opts.forceRef) {
                needRef = true;
            } else {
                needRef = builder.availableBits - 2 /* At least two bits for ref flags */  < initCell.bits + message.body.bits.length;
            }
            // Persist init
            if (needRef) {
                builder.storeBit(true);
                builder.storeRef(initCell);
            } else {
                builder.storeBit(false);
                builder.storeBuilder(initCell);
            }
        } else {
            builder.storeBit(false);
        }
        // Store body
        let needRef = false;
        if (opts && opts.forceRef) {
            needRef = true;
        } else {
            needRef = builder.availableBits - 1 /* At least one bit for ref flag */  < message.body.bits.length || builder.refs + message.body.refs.length > 4;
        }
        if (needRef) {
            builder.storeBit(true);
            builder.storeRef(message.body);
        } else {
            builder.storeBit(false);
            builder.storeBuilder(message.body.asBuilder());
        }
    };
}
exports.storeMessage = storeMessage;
exports.MessageValue = {
    serialize (src, builder) {
        builder.storeRef((0, Builder_1.beginCell)().store(storeMessage(src)));
    },
    parse (slice) {
        return loadMessage(slice.loadRef().beginParse());
    }
};
}),
"[project]/node_modules/@ton/core/dist/types/SendMode.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SendMode = void 0;
var SendMode;
(function(SendMode) {
    SendMode[SendMode["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
    SendMode[SendMode["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
    SendMode[SendMode["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
    SendMode[SendMode["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
    SendMode[SendMode["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
    SendMode[SendMode["NONE"] = 0] = "NONE";
})(SendMode || (exports.SendMode = SendMode = {}));
}),
"[project]/node_modules/@ton/core/dist/types/ReserveMode.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReserveMode = void 0;
var ReserveMode;
(function(ReserveMode) {
    ReserveMode[ReserveMode["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
    ReserveMode[ReserveMode["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
    ReserveMode[ReserveMode["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
    ReserveMode[ReserveMode["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
    ReserveMode[ReserveMode["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
    ReserveMode[ReserveMode["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
    ReserveMode[ReserveMode["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
    ReserveMode[ReserveMode["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
})(ReserveMode || (exports.ReserveMode = ReserveMode = {}));
}),
"[project]/node_modules/@ton/core/dist/types/ShardAccount.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeShardAccount = exports.loadShardAccount = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const Account_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/Account.js [client] (ecmascript)");
function loadShardAccount(slice) {
    let accountRef = slice.loadRef();
    let account = undefined;
    if (!accountRef.isExotic) {
        let accountSlice = accountRef.beginParse();
        if (accountSlice.loadBit()) {
            account = (0, Account_1.loadAccount)(accountSlice);
        }
    }
    return {
        account,
        lastTransactionHash: slice.loadUintBig(256),
        lastTransactionLt: slice.loadUintBig(64)
    };
}
exports.loadShardAccount = loadShardAccount;
function storeShardAccount(src) {
    return (builder)=>{
        if (src.account) {
            builder.storeRef((0, Builder_1.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
        } else {
            builder.storeRef((0, Builder_1.beginCell)().storeBit(false));
        }
        builder.storeUint(src.lastTransactionHash, 256);
        builder.storeUint(src.lastTransactionLt, 64);
    };
}
exports.storeShardAccount = storeShardAccount;
}),
"[project]/node_modules/@ton/core/dist/types/ShardAccounts.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
const DepthBalanceInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/DepthBalanceInfo.js [client] (ecmascript)");
const ShardAccount_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardAccount.js [client] (ecmascript)");
exports.ShardAccountRefValue = {
    parse: (cs)=>{
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
            depthBalanceInfo,
            shardAccount
        };
    },
    serialize (src, builder) {
        builder.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
    }
};
function loadShardAccounts(cs) {
    return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
}
exports.loadShardAccounts = loadShardAccounts;
function storeShardAccounts(src) {
    return (Builder)=>{
        Builder.storeDict(src);
    };
}
exports.storeShardAccounts = storeShardAccounts;
}),
"[project]/node_modules/@ton/core/dist/types/ShardIdent.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeShardIdent = exports.loadShardIdent = void 0;
function loadShardIdent(slice) {
    if (slice.loadUint(2) !== 0) {
        throw Error('Invalid data');
    }
    return {
        shardPrefixBits: slice.loadUint(6),
        workchainId: slice.loadInt(32),
        shardPrefix: slice.loadUintBig(64)
    };
}
exports.loadShardIdent = loadShardIdent;
function storeShardIdent(src) {
    return (builder)=>{
        builder.storeUint(0, 2);
        builder.storeUint(src.shardPrefixBits, 6);
        builder.storeInt(src.workchainId, 32);
        builder.storeUint(src.shardPrefix, 64);
    };
}
exports.storeShardIdent = storeShardIdent;
}),
"[project]/node_modules/@ton/core/dist/types/ShardStateUnsplit.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadShardStateUnsplit = void 0;
const MasterchainStateExtra_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/MasterchainStateExtra.js [client] (ecmascript)");
const ShardAccounts_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardAccounts.js [client] (ecmascript)");
const ShardIdent_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardIdent.js [client] (ecmascript)");
function loadShardStateUnsplit(cs) {
    if (cs.loadUint(32) !== 0x9023afe2) {
        throw Error('Invalid data');
    }
    let globalId = cs.loadInt(32);
    let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
    let seqno = cs.loadUint(32);
    let vertSeqNo = cs.loadUint(32);
    let genUtime = cs.loadUint(32);
    let genLt = cs.loadUintBig(64);
    let minRefMcSeqno = cs.loadUint(32);
    // Skip OutMsgQueueInfo: usually exotic
    cs.loadRef();
    let beforeSplit = cs.loadBit();
    // Parse accounts
    let shardAccountsRef = cs.loadRef();
    let accounts = undefined;
    if (!shardAccountsRef.isExotic) {
        accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
    }
    // Skip (not used by apps)
    cs.loadRef();
    // Parse extras
    let mcStateExtra = cs.loadBit();
    let extras = null;
    if (mcStateExtra) {
        let cell = cs.loadRef();
        if (!cell.isExotic) {
            extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
        }
    }
    ;
    return {
        globalId,
        shardId,
        seqno,
        vertSeqNo,
        genUtime,
        genLt,
        minRefMcSeqno,
        beforeSplit,
        accounts,
        extras
    };
}
exports.loadShardStateUnsplit = loadShardStateUnsplit;
}),
"[project]/node_modules/@ton/core/dist/types/SplitMergeInfo.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = void 0;
function loadSplitMergeInfo(slice) {
    let currentShardPrefixLength = slice.loadUint(6);
    let accountSplitDepth = slice.loadUint(6);
    let thisAddress = slice.loadUintBig(256);
    let siblingAddress = slice.loadUintBig(256);
    return {
        currentShardPrefixLength,
        accountSplitDepth,
        thisAddress,
        siblingAddress
    };
}
exports.loadSplitMergeInfo = loadSplitMergeInfo;
function storeSplitMergeInfo(src) {
    return (builder)=>{
        builder.storeUint(src.currentShardPrefixLength, 6);
        builder.storeUint(src.accountSplitDepth, 6);
        builder.storeUint(src.thisAddress, 256);
        builder.storeUint(src.siblingAddress, 256);
    };
}
exports.storeSplitMergeInfo = storeSplitMergeInfo;
}),
"[project]/node_modules/@ton/core/dist/types/TransactionActionPhase.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = void 0;
const AccountStatusChange_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStatusChange.js [client] (ecmascript)");
const StorageUsed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageUsed.js [client] (ecmascript)");
function loadTransactionActionPhase(slice) {
    let success = slice.loadBit();
    let valid = slice.loadBit();
    let noFunds = slice.loadBit();
    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : undefined;
    let totalActionFees = slice.loadBit() ? slice.loadCoins() : undefined;
    let resultCode = slice.loadInt(32);
    let resultArg = slice.loadBit() ? slice.loadInt(32) : undefined;
    let totalActions = slice.loadUint(16);
    let specActions = slice.loadUint(16);
    let skippedActions = slice.loadUint(16);
    let messagesCreated = slice.loadUint(16);
    let actionListHash = slice.loadUintBig(256);
    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
    return {
        success,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSize
    };
}
exports.loadTransactionActionPhase = loadTransactionActionPhase;
function storeTransactionActionPhase(src) {
    return (builder)=>{
        builder.storeBit(src.success);
        builder.storeBit(src.valid);
        builder.storeBit(src.noFunds);
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
        builder.storeMaybeCoins(src.totalFwdFees);
        builder.storeMaybeCoins(src.totalActionFees);
        builder.storeInt(src.resultCode, 32);
        builder.storeMaybeInt(src.resultArg, 32);
        builder.storeUint(src.totalActions, 16);
        builder.storeUint(src.specActions, 16);
        builder.storeUint(src.skippedActions, 16);
        builder.storeUint(src.messagesCreated, 16);
        builder.storeUint(src.actionListHash, 256);
        builder.store((0, StorageUsed_1.storeStorageUsed)(src.totalMessageSize));
    };
}
exports.storeTransactionActionPhase = storeTransactionActionPhase;
}),
"[project]/node_modules/@ton/core/dist/types/TransactionBouncePhase.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = void 0;
const StorageUsed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageUsed.js [client] (ecmascript)");
function loadTransactionBouncePhase(slice) {
    // Ok
    if (slice.loadBit()) {
        let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
        let messageFees = slice.loadCoins();
        let forwardFees = slice.loadCoins();
        return {
            type: "ok",
            messageSize,
            messageFees,
            forwardFees
        };
    }
    // No funds
    if (slice.loadBit()) {
        let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
        let requiredForwardFees = slice.loadCoins();
        return {
            type: "no-funds",
            messageSize,
            requiredForwardFees
        };
    }
    // Negative funds
    return {
        type: "negative-funds"
    };
}
exports.loadTransactionBouncePhase = loadTransactionBouncePhase;
function storeTransactionBouncePhase(src) {
    return (builder)=>{
        if (src.type === 'ok') {
            builder.storeBit(true);
            builder.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
            builder.storeCoins(src.messageFees);
            builder.storeCoins(src.forwardFees);
        } else if (src.type === 'negative-funds') {
            builder.storeBit(false);
            builder.storeBit(false);
        } else if (src.type === 'no-funds') {
            builder.storeBit(false);
            builder.storeBit(true);
            builder.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
            builder.storeCoins(src.requiredForwardFees);
        } else {
            throw new Error("Invalid TransactionBouncePhase type");
        }
    };
}
exports.storeTransactionBouncePhase = storeTransactionBouncePhase;
}),
"[project]/node_modules/@ton/core/dist/types/TransactionComputePhase.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const ComputeSkipReason_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ComputeSkipReason.js [client] (ecmascript)");
function loadTransactionComputePhase(slice) {
    // Skipped
    if (!slice.loadBit()) {
        let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
        return {
            type: 'skipped',
            reason
        };
    }
    let success = slice.loadBit();
    let messageStateUsed = slice.loadBit();
    let accountActivated = slice.loadBit();
    let gasFees = slice.loadCoins();
    const vmState = slice.loadRef().beginParse();
    let gasUsed = vmState.loadVarUintBig(3);
    let gasLimit = vmState.loadVarUintBig(3);
    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : undefined;
    let mode = vmState.loadUint(8);
    let exitCode = vmState.loadInt(32);
    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : undefined;
    let vmSteps = vmState.loadUint(32);
    let vmInitStateHash = vmState.loadUintBig(256);
    let vmFinalStateHash = vmState.loadUintBig(256);
    return {
        type: 'vm',
        success,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
    };
}
exports.loadTransactionComputePhase = loadTransactionComputePhase;
function storeTransactionComputePhase(src) {
    return (builder)=>{
        if (src.type === 'skipped') {
            builder.storeBit(0);
            builder.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
            return;
        }
        builder.storeBit(1);
        builder.storeBit(src.success);
        builder.storeBit(src.messageStateUsed);
        builder.storeBit(src.accountActivated);
        builder.storeCoins(src.gasFees);
        builder.storeRef((0, Builder_1.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b)=>src.gasCredit !== undefined && src.gasCredit !== null ? b.storeBit(1).storeVarUint(src.gasCredit, 2) : b.storeBit(0)).storeUint(src.mode, 8).storeInt(src.exitCode, 32).store((b)=>src.exitArg !== undefined && src.exitArg !== null ? b.storeBit(1).storeInt(src.exitArg, 32) : b.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
    };
}
exports.storeTransactionComputePhase = storeTransactionComputePhase;
}),
"[project]/node_modules/@ton/core/dist/types/TransactionCreditPhase.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = void 0;
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
function loadTransactionCreditPhase(slice) {
    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : undefined;
    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    return {
        dueFeesColelcted,
        credit
    };
}
exports.loadTransactionCreditPhase = loadTransactionCreditPhase;
function storeTransactionCreditPhase(src) {
    return (builder)=>{
        if (src.dueFeesColelcted === null || src.dueFeesColelcted === undefined) {
            builder.storeBit(false);
        } else {
            builder.storeBit(true);
            builder.storeCoins(src.dueFeesColelcted);
        }
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
    };
}
exports.storeTransactionCreditPhase = storeTransactionCreditPhase;
}),
"[project]/node_modules/@ton/core/dist/types/TransactionStoragePhase.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = void 0;
const AccountStatusChange_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStatusChange.js [client] (ecmascript)");
function loadTransactionStoragePhase(slice) {
    const storageFeesCollected = slice.loadCoins();
    let storageFeesDue = undefined;
    if (slice.loadBit()) {
        storageFeesDue = slice.loadCoins();
    }
    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
    return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
    };
}
exports.loadTransactionStoragePhase = loadTransactionStoragePhase;
function storeTransactionsStoragePhase(src) {
    return (builder)=>{
        builder.storeCoins(src.storageFeesCollected);
        if (src.storageFeesDue === null || src.storageFeesDue === undefined) {
            builder.storeBit(false);
        } else {
            builder.storeBit(true);
            builder.storeCoins(src.storageFeesDue);
        }
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
    };
}
exports.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
}),
"[project]/node_modules/@ton/core/dist/types/TransactionDescription.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransactionDescription = exports.loadTransactionDescription = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const SplitMergeInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/SplitMergeInfo.js [client] (ecmascript)");
const Transaction_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/Transaction.js [client] (ecmascript)");
const TransactionActionPhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionActionPhase.js [client] (ecmascript)");
const TransactionBouncePhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionBouncePhase.js [client] (ecmascript)");
const TransactionComputePhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionComputePhase.js [client] (ecmascript)");
const TransactionCreditPhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionCreditPhase.js [client] (ecmascript)");
const TransactionStoragePhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionStoragePhase.js [client] (ecmascript)");
function loadTransactionDescription(slice) {
    let type = slice.loadUint(4);
    if (type === 0x00) {
        const creditFirst = slice.loadBit();
        let storagePhase = undefined;
        if (slice.loadBit()) {
            storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let creditPhase = undefined;
        if (slice.loadBit()) {
            creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = undefined;
        if (slice.loadBit()) {
            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        let aborted = slice.loadBit();
        let bouncePhase = undefined;
        if (slice.loadBit()) {
            bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
        }
        const destroyed = slice.loadBit();
        return {
            type: 'generic',
            creditFirst,
            storagePhase,
            creditPhase,
            computePhase,
            actionPhase,
            bouncePhase,
            aborted,
            destroyed
        };
    }
    if (type === 0x01) {
        return {
            type: 'storage',
            storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
        };
    }
    if (type === 0x2 || type === 0x03) {
        const isTock = type === 0x03;
        let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = undefined;
        if (slice.loadBit()) {
            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
            type: 'tick-tock',
            isTock,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
        };
    }
    if (type === 0x04) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let storagePhase = undefined;
        if (slice.loadBit()) {
            storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = undefined;
        if (slice.loadBit()) {
            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
            type: 'split-prepare',
            splitInfo,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
        };
    }
    if (type === 0x05) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
        const installed = slice.loadBit();
        return {
            type: 'split-install',
            splitInfo,
            prepareTransaction,
            installed
        };
    }
    throw Error(`Unsupported transaction description type ${type}`);
}
exports.loadTransactionDescription = loadTransactionDescription;
function storeTransactionDescription(src) {
    return (builder)=>{
        if (src.type === 'generic') {
            builder.storeUint(0x00, 4);
            builder.storeBit(src.creditFirst);
            if (src.storagePhase) {
                builder.storeBit(true);
                builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
            } else {
                builder.storeBit(false);
            }
            if (src.creditPhase) {
                builder.storeBit(true);
                builder.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
            } else {
                builder.storeBit(false);
            }
            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
            if (src.actionPhase) {
                builder.storeBit(true);
                builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
            } else {
                builder.storeBit(false);
            }
            builder.storeBit(src.aborted);
            if (src.bouncePhase) {
                builder.storeBit(true);
                builder.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
            } else {
                builder.storeBit(false);
            }
            builder.storeBit(src.destroyed);
        } else if (src.type === 'storage') {
            builder.storeUint(0x01, 4);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else if (src.type === 'tick-tock') {
            builder.storeUint(src.isTock ? 0x03 : 0x02, 4);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
            if (src.actionPhase) {
                builder.storeBit(true);
                builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
            } else {
                builder.storeBit(false);
            }
            builder.storeBit(src.aborted);
            builder.storeBit(src.destroyed);
        } else if (src.type === 'split-prepare') {
            builder.storeUint(0x04, 4);
            builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
            if (src.storagePhase) {
                builder.storeBit(true);
                builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
            } else {
                builder.storeBit(false);
            }
            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
            if (src.actionPhase) {
                builder.storeBit(true);
                builder.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
            } else {
                builder.storeBit(false);
            }
            builder.storeBit(src.aborted);
            builder.storeBit(src.destroyed);
        } else if (src.type === 'split-install') {
            builder.storeUint(0x05, 4);
            builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
            builder.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
            builder.storeBit(src.installed);
        } else {
            throw Error(`Unsupported transaction description type ${src.type}`);
        }
    };
}
exports.storeTransactionDescription = storeTransactionDescription;
}),
"[project]/node_modules/@ton/core/dist/types/Transaction.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storeTransaction = exports.loadTransaction = void 0;
const Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
const Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
const AccountStatus_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStatus.js [client] (ecmascript)");
const CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
const HashUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/HashUpdate.js [client] (ecmascript)");
const Message_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/Message.js [client] (ecmascript)");
const TransactionDescription_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionDescription.js [client] (ecmascript)");
function loadTransaction(slice) {
    let raw = slice.asCell();
    if (slice.loadUint(4) !== 0x07) {
        throw Error('Invalid data');
    }
    let address = slice.loadUintBig(256);
    let lt = slice.loadUintBig(64);
    let prevTransactionHash = slice.loadUintBig(256);
    let prevTransactionLt = slice.loadUintBig(64);
    let now = slice.loadUint(32);
    let outMessagesCount = slice.loadUint(15);
    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
    let msgRef = slice.loadRef();
    let msgSlice = msgRef.beginParse();
    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : undefined;
    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
    msgSlice.endParse();
    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
    return {
        address,
        lt,
        prevTransactionHash,
        prevTransactionLt,
        now,
        outMessagesCount,
        oldStatus,
        endStatus,
        inMessage,
        outMessages,
        totalFees,
        stateUpdate,
        description,
        raw,
        hash: ()=>raw.hash()
    };
}
exports.loadTransaction = loadTransaction;
function storeTransaction(src) {
    return (builder)=>{
        builder.storeUint(0x07, 4);
        builder.storeUint(src.address, 256);
        builder.storeUint(src.lt, 64);
        builder.storeUint(src.prevTransactionHash, 256);
        builder.storeUint(src.prevTransactionLt, 64);
        builder.storeUint(src.now, 32);
        builder.storeUint(src.outMessagesCount, 15);
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
        let msgBuilder = (0, Builder_1.beginCell)();
        if (src.inMessage) {
            msgBuilder.storeBit(true);
            msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
        } else {
            msgBuilder.storeBit(false);
        }
        msgBuilder.storeDict(src.outMessages);
        builder.storeRef(msgBuilder);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
        builder.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
        builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
    };
}
exports.storeTransaction = storeTransaction;
}),
"[project]/node_modules/@ton/core/dist/types/_export.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
var _helpers_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/_helpers.js [client] (ecmascript)");
Object.defineProperty(exports, "internal", {
    enumerable: true,
    get: function() {
        return _helpers_1.internal;
    }
});
Object.defineProperty(exports, "external", {
    enumerable: true,
    get: function() {
        return _helpers_1.external;
    }
});
Object.defineProperty(exports, "comment", {
    enumerable: true,
    get: function() {
        return _helpers_1.comment;
    }
});
var Account_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/Account.js [client] (ecmascript)");
Object.defineProperty(exports, "loadAccount", {
    enumerable: true,
    get: function() {
        return Account_1.loadAccount;
    }
});
Object.defineProperty(exports, "storeAccount", {
    enumerable: true,
    get: function() {
        return Account_1.storeAccount;
    }
});
var AccountState_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountState.js [client] (ecmascript)");
Object.defineProperty(exports, "loadAccountState", {
    enumerable: true,
    get: function() {
        return AccountState_1.loadAccountState;
    }
});
Object.defineProperty(exports, "storeAccountState", {
    enumerable: true,
    get: function() {
        return AccountState_1.storeAccountState;
    }
});
var AccountStatus_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStatus.js [client] (ecmascript)");
Object.defineProperty(exports, "loadAccountStatus", {
    enumerable: true,
    get: function() {
        return AccountStatus_1.loadAccountStatus;
    }
});
Object.defineProperty(exports, "storeAccountStatus", {
    enumerable: true,
    get: function() {
        return AccountStatus_1.storeAccountStatus;
    }
});
var AccountStatusChange_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStatusChange.js [client] (ecmascript)");
Object.defineProperty(exports, "loadAccountStatusChange", {
    enumerable: true,
    get: function() {
        return AccountStatusChange_1.loadAccountStatusChange;
    }
});
Object.defineProperty(exports, "storeAccountStatusChange", {
    enumerable: true,
    get: function() {
        return AccountStatusChange_1.storeAccountStatusChange;
    }
});
var AccountStorage_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/AccountStorage.js [client] (ecmascript)");
Object.defineProperty(exports, "loadAccountStorage", {
    enumerable: true,
    get: function() {
        return AccountStorage_1.loadAccountStorage;
    }
});
Object.defineProperty(exports, "storeAccountStorage", {
    enumerable: true,
    get: function() {
        return AccountStorage_1.storeAccountStorage;
    }
});
var OutList_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/OutList.js [client] (ecmascript)");
Object.defineProperty(exports, "loadOutAction", {
    enumerable: true,
    get: function() {
        return OutList_1.loadOutAction;
    }
});
Object.defineProperty(exports, "storeOutAction", {
    enumerable: true,
    get: function() {
        return OutList_1.storeOutAction;
    }
});
Object.defineProperty(exports, "loadOutList", {
    enumerable: true,
    get: function() {
        return OutList_1.loadOutList;
    }
});
Object.defineProperty(exports, "storeOutList", {
    enumerable: true,
    get: function() {
        return OutList_1.storeOutList;
    }
});
var CommonMessageInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CommonMessageInfo.js [client] (ecmascript)");
Object.defineProperty(exports, "loadCommonMessageInfo", {
    enumerable: true,
    get: function() {
        return CommonMessageInfo_1.loadCommonMessageInfo;
    }
});
Object.defineProperty(exports, "storeCommonMessageInfo", {
    enumerable: true,
    get: function() {
        return CommonMessageInfo_1.storeCommonMessageInfo;
    }
});
var CommonMessageInfoRelaxed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CommonMessageInfoRelaxed.js [client] (ecmascript)");
Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", {
    enumerable: true,
    get: function() {
        return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    }
});
Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", {
    enumerable: true,
    get: function() {
        return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    }
});
var ComputeSkipReason_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ComputeSkipReason.js [client] (ecmascript)");
Object.defineProperty(exports, "loadComputeSkipReason", {
    enumerable: true,
    get: function() {
        return ComputeSkipReason_1.loadComputeSkipReason;
    }
});
Object.defineProperty(exports, "storeComputeSkipReason", {
    enumerable: true,
    get: function() {
        return ComputeSkipReason_1.storeComputeSkipReason;
    }
});
var CurrencyCollection_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/CurrencyCollection.js [client] (ecmascript)");
Object.defineProperty(exports, "loadCurrencyCollection", {
    enumerable: true,
    get: function() {
        return CurrencyCollection_1.loadCurrencyCollection;
    }
});
Object.defineProperty(exports, "storeCurrencyCollection", {
    enumerable: true,
    get: function() {
        return CurrencyCollection_1.storeCurrencyCollection;
    }
});
var DepthBalanceInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/DepthBalanceInfo.js [client] (ecmascript)");
Object.defineProperty(exports, "loadDepthBalanceInfo", {
    enumerable: true,
    get: function() {
        return DepthBalanceInfo_1.loadDepthBalanceInfo;
    }
});
Object.defineProperty(exports, "storeDepthBalanceInfo", {
    enumerable: true,
    get: function() {
        return DepthBalanceInfo_1.storeDepthBalanceInfo;
    }
});
var ExtraCurrency_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ExtraCurrency.js [client] (ecmascript)");
Object.defineProperty(exports, "packExtraCurrencyCell", {
    enumerable: true,
    get: function() {
        return ExtraCurrency_1.packExtraCurrencyCell;
    }
});
Object.defineProperty(exports, "packExtraCurrencyDict", {
    enumerable: true,
    get: function() {
        return ExtraCurrency_1.packExtraCurrencyDict;
    }
});
Object.defineProperty(exports, "loadExtraCurrency", {
    enumerable: true,
    get: function() {
        return ExtraCurrency_1.loadExtraCurrency;
    }
});
Object.defineProperty(exports, "loadMaybeExtraCurrency", {
    enumerable: true,
    get: function() {
        return ExtraCurrency_1.loadMaybeExtraCurrency;
    }
});
Object.defineProperty(exports, "storeExtraCurrency", {
    enumerable: true,
    get: function() {
        return ExtraCurrency_1.storeExtraCurrency;
    }
});
var HashUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/HashUpdate.js [client] (ecmascript)");
Object.defineProperty(exports, "loadHashUpdate", {
    enumerable: true,
    get: function() {
        return HashUpdate_1.loadHashUpdate;
    }
});
Object.defineProperty(exports, "storeHashUpdate", {
    enumerable: true,
    get: function() {
        return HashUpdate_1.storeHashUpdate;
    }
});
var MasterchainStateExtra_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/MasterchainStateExtra.js [client] (ecmascript)");
Object.defineProperty(exports, "loadMasterchainStateExtra", {
    enumerable: true,
    get: function() {
        return MasterchainStateExtra_1.loadMasterchainStateExtra;
    }
});
var Message_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/Message.js [client] (ecmascript)");
Object.defineProperty(exports, "loadMessage", {
    enumerable: true,
    get: function() {
        return Message_1.loadMessage;
    }
});
Object.defineProperty(exports, "storeMessage", {
    enumerable: true,
    get: function() {
        return Message_1.storeMessage;
    }
});
var MessageRelaxed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/MessageRelaxed.js [client] (ecmascript)");
Object.defineProperty(exports, "loadMessageRelaxed", {
    enumerable: true,
    get: function() {
        return MessageRelaxed_1.loadMessageRelaxed;
    }
});
Object.defineProperty(exports, "storeMessageRelaxed", {
    enumerable: true,
    get: function() {
        return MessageRelaxed_1.storeMessageRelaxed;
    }
});
var SendMode_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/SendMode.js [client] (ecmascript)");
Object.defineProperty(exports, "SendMode", {
    enumerable: true,
    get: function() {
        return SendMode_1.SendMode;
    }
});
var ReserveMode_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ReserveMode.js [client] (ecmascript)");
Object.defineProperty(exports, "ReserveMode", {
    enumerable: true,
    get: function() {
        return ReserveMode_1.ReserveMode;
    }
});
var ShardAccount_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardAccount.js [client] (ecmascript)");
Object.defineProperty(exports, "loadShardAccount", {
    enumerable: true,
    get: function() {
        return ShardAccount_1.loadShardAccount;
    }
});
Object.defineProperty(exports, "storeShardAccount", {
    enumerable: true,
    get: function() {
        return ShardAccount_1.storeShardAccount;
    }
});
var ShardAccounts_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardAccounts.js [client] (ecmascript)");
Object.defineProperty(exports, "ShardAccountRefValue", {
    enumerable: true,
    get: function() {
        return ShardAccounts_1.ShardAccountRefValue;
    }
});
Object.defineProperty(exports, "loadShardAccounts", {
    enumerable: true,
    get: function() {
        return ShardAccounts_1.loadShardAccounts;
    }
});
Object.defineProperty(exports, "storeShardAccounts", {
    enumerable: true,
    get: function() {
        return ShardAccounts_1.storeShardAccounts;
    }
});
var ShardIdent_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardIdent.js [client] (ecmascript)");
Object.defineProperty(exports, "loadShardIdent", {
    enumerable: true,
    get: function() {
        return ShardIdent_1.loadShardIdent;
    }
});
Object.defineProperty(exports, "storeShardIdent", {
    enumerable: true,
    get: function() {
        return ShardIdent_1.storeShardIdent;
    }
});
var ShardStateUnsplit_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/ShardStateUnsplit.js [client] (ecmascript)");
Object.defineProperty(exports, "loadShardStateUnsplit", {
    enumerable: true,
    get: function() {
        return ShardStateUnsplit_1.loadShardStateUnsplit;
    }
});
var SimpleLibrary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/SimpleLibrary.js [client] (ecmascript)");
Object.defineProperty(exports, "loadSimpleLibrary", {
    enumerable: true,
    get: function() {
        return SimpleLibrary_1.loadSimpleLibrary;
    }
});
Object.defineProperty(exports, "storeSimpleLibrary", {
    enumerable: true,
    get: function() {
        return SimpleLibrary_1.storeSimpleLibrary;
    }
});
var LibRef_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/LibRef.js [client] (ecmascript)");
Object.defineProperty(exports, "loadLibRef", {
    enumerable: true,
    get: function() {
        return LibRef_1.loadLibRef;
    }
});
Object.defineProperty(exports, "storeLibRef", {
    enumerable: true,
    get: function() {
        return LibRef_1.storeLibRef;
    }
});
var SplitMergeInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/SplitMergeInfo.js [client] (ecmascript)");
Object.defineProperty(exports, "loadSplitMergeInfo", {
    enumerable: true,
    get: function() {
        return SplitMergeInfo_1.loadSplitMergeInfo;
    }
});
Object.defineProperty(exports, "storeSplitMergeInfo", {
    enumerable: true,
    get: function() {
        return SplitMergeInfo_1.storeSplitMergeInfo;
    }
});
var StateInit_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StateInit.js [client] (ecmascript)");
Object.defineProperty(exports, "loadStateInit", {
    enumerable: true,
    get: function() {
        return StateInit_1.loadStateInit;
    }
});
Object.defineProperty(exports, "storeStateInit", {
    enumerable: true,
    get: function() {
        return StateInit_1.storeStateInit;
    }
});
var StorageInfo_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageInfo.js [client] (ecmascript)");
Object.defineProperty(exports, "loadStorageInfo", {
    enumerable: true,
    get: function() {
        return StorageInfo_1.loadStorageInfo;
    }
});
Object.defineProperty(exports, "storeStorageInfo", {
    enumerable: true,
    get: function() {
        return StorageInfo_1.storeStorageInfo;
    }
});
var StorageUsed_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/StorageUsed.js [client] (ecmascript)");
Object.defineProperty(exports, "loadStorageUsed", {
    enumerable: true,
    get: function() {
        return StorageUsed_1.loadStorageUsed;
    }
});
Object.defineProperty(exports, "storeStorageUsed", {
    enumerable: true,
    get: function() {
        return StorageUsed_1.storeStorageUsed;
    }
});
var TickTock_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TickTock.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTickTock", {
    enumerable: true,
    get: function() {
        return TickTock_1.loadTickTock;
    }
});
Object.defineProperty(exports, "storeTickTock", {
    enumerable: true,
    get: function() {
        return TickTock_1.storeTickTock;
    }
});
var Transaction_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/Transaction.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransaction", {
    enumerable: true,
    get: function() {
        return Transaction_1.loadTransaction;
    }
});
Object.defineProperty(exports, "storeTransaction", {
    enumerable: true,
    get: function() {
        return Transaction_1.storeTransaction;
    }
});
var TransactionActionPhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionActionPhase.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransactionActionPhase", {
    enumerable: true,
    get: function() {
        return TransactionActionPhase_1.loadTransactionActionPhase;
    }
});
Object.defineProperty(exports, "storeTransactionActionPhase", {
    enumerable: true,
    get: function() {
        return TransactionActionPhase_1.storeTransactionActionPhase;
    }
});
var TransactionBouncePhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionBouncePhase.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransactionBouncePhase", {
    enumerable: true,
    get: function() {
        return TransactionBouncePhase_1.loadTransactionBouncePhase;
    }
});
Object.defineProperty(exports, "storeTransactionBouncePhase", {
    enumerable: true,
    get: function() {
        return TransactionBouncePhase_1.storeTransactionBouncePhase;
    }
});
var TransactionComputePhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionComputePhase.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransactionComputePhase", {
    enumerable: true,
    get: function() {
        return TransactionComputePhase_1.loadTransactionComputePhase;
    }
});
Object.defineProperty(exports, "storeTransactionComputePhase", {
    enumerable: true,
    get: function() {
        return TransactionComputePhase_1.storeTransactionComputePhase;
    }
});
var TransactionCreditPhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionCreditPhase.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransactionCreditPhase", {
    enumerable: true,
    get: function() {
        return TransactionCreditPhase_1.loadTransactionCreditPhase;
    }
});
Object.defineProperty(exports, "storeTransactionCreditPhase", {
    enumerable: true,
    get: function() {
        return TransactionCreditPhase_1.storeTransactionCreditPhase;
    }
});
var TransactionDescription_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionDescription.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransactionDescription", {
    enumerable: true,
    get: function() {
        return TransactionDescription_1.loadTransactionDescription;
    }
});
Object.defineProperty(exports, "storeTransactionDescription", {
    enumerable: true,
    get: function() {
        return TransactionDescription_1.storeTransactionDescription;
    }
});
var TransactionStoragePhase_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/TransactionStoragePhase.js [client] (ecmascript)");
Object.defineProperty(exports, "loadTransactionStoragePhase", {
    enumerable: true,
    get: function() {
        return TransactionStoragePhase_1.loadTransactionStoragePhase;
    }
});
Object.defineProperty(exports, "storeTransactionsStoragePhase", {
    enumerable: true,
    get: function() {
        return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    }
});
}),
"[project]/node_modules/@ton/core/dist/contract/openContract.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.openContract = void 0;
const Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
const Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
function openContract(src, factory) {
    // Resolve parameters
    let address;
    let init = null;
    if (!Address_1.Address.isAddress(src.address)) {
        throw Error('Invalid address');
    }
    address = src.address;
    if (src.init) {
        if (!(src.init.code instanceof Cell_1.Cell)) {
            throw Error('Invalid init.code');
        }
        if (!(src.init.data instanceof Cell_1.Cell)) {
            throw Error('Invalid init.data');
        }
        init = src.init;
    }
    // Create executor
    let executor = factory({
        address,
        init
    });
    // Create proxy
    return new Proxy(src, {
        get (target, prop) {
            const value = target[prop];
            if (typeof prop === 'string' && (prop.startsWith('get') || prop.startsWith('send') || prop.startsWith('is'))) {
                if (typeof value === 'function') {
                    return (...args)=>value.apply(target, [
                            executor,
                            ...args
                        ]);
                }
            }
            return value;
        }
    });
}
exports.openContract = openContract;
}),
"[project]/node_modules/@ton/core/dist/contract/ComputeError.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ComputeError = void 0;
class ComputeError extends Error {
    constructor(message, exitCode, opts){
        super(message);
        this.exitCode = exitCode;
        this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
        this.logs = opts && opts.logs ? opts.logs : null;
        Object.setPrototypeOf(this, ComputeError.prototype);
    }
}
exports.ComputeError = ComputeError;
}),
"[project]/node_modules/@ton/core/dist/utils/getMethodId.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMethodId = void 0;
const TABLE = new Int16Array([
    0x0000,
    0x1021,
    0x2042,
    0x3063,
    0x4084,
    0x50a5,
    0x60c6,
    0x70e7,
    0x8108,
    0x9129,
    0xa14a,
    0xb16b,
    0xc18c,
    0xd1ad,
    0xe1ce,
    0xf1ef,
    0x1231,
    0x0210,
    0x3273,
    0x2252,
    0x52b5,
    0x4294,
    0x72f7,
    0x62d6,
    0x9339,
    0x8318,
    0xb37b,
    0xa35a,
    0xd3bd,
    0xc39c,
    0xf3ff,
    0xe3de,
    0x2462,
    0x3443,
    0x0420,
    0x1401,
    0x64e6,
    0x74c7,
    0x44a4,
    0x5485,
    0xa56a,
    0xb54b,
    0x8528,
    0x9509,
    0xe5ee,
    0xf5cf,
    0xc5ac,
    0xd58d,
    0x3653,
    0x2672,
    0x1611,
    0x0630,
    0x76d7,
    0x66f6,
    0x5695,
    0x46b4,
    0xb75b,
    0xa77a,
    0x9719,
    0x8738,
    0xf7df,
    0xe7fe,
    0xd79d,
    0xc7bc,
    0x48c4,
    0x58e5,
    0x6886,
    0x78a7,
    0x0840,
    0x1861,
    0x2802,
    0x3823,
    0xc9cc,
    0xd9ed,
    0xe98e,
    0xf9af,
    0x8948,
    0x9969,
    0xa90a,
    0xb92b,
    0x5af5,
    0x4ad4,
    0x7ab7,
    0x6a96,
    0x1a71,
    0x0a50,
    0x3a33,
    0x2a12,
    0xdbfd,
    0xcbdc,
    0xfbbf,
    0xeb9e,
    0x9b79,
    0x8b58,
    0xbb3b,
    0xab1a,
    0x6ca6,
    0x7c87,
    0x4ce4,
    0x5cc5,
    0x2c22,
    0x3c03,
    0x0c60,
    0x1c41,
    0xedae,
    0xfd8f,
    0xcdec,
    0xddcd,
    0xad2a,
    0xbd0b,
    0x8d68,
    0x9d49,
    0x7e97,
    0x6eb6,
    0x5ed5,
    0x4ef4,
    0x3e13,
    0x2e32,
    0x1e51,
    0x0e70,
    0xff9f,
    0xefbe,
    0xdfdd,
    0xcffc,
    0xbf1b,
    0xaf3a,
    0x9f59,
    0x8f78,
    0x9188,
    0x81a9,
    0xb1ca,
    0xa1eb,
    0xd10c,
    0xc12d,
    0xf14e,
    0xe16f,
    0x1080,
    0x00a1,
    0x30c2,
    0x20e3,
    0x5004,
    0x4025,
    0x7046,
    0x6067,
    0x83b9,
    0x9398,
    0xa3fb,
    0xb3da,
    0xc33d,
    0xd31c,
    0xe37f,
    0xf35e,
    0x02b1,
    0x1290,
    0x22f3,
    0x32d2,
    0x4235,
    0x5214,
    0x6277,
    0x7256,
    0xb5ea,
    0xa5cb,
    0x95a8,
    0x8589,
    0xf56e,
    0xe54f,
    0xd52c,
    0xc50d,
    0x34e2,
    0x24c3,
    0x14a0,
    0x0481,
    0x7466,
    0x6447,
    0x5424,
    0x4405,
    0xa7db,
    0xb7fa,
    0x8799,
    0x97b8,
    0xe75f,
    0xf77e,
    0xc71d,
    0xd73c,
    0x26d3,
    0x36f2,
    0x0691,
    0x16b0,
    0x6657,
    0x7676,
    0x4615,
    0x5634,
    0xd94c,
    0xc96d,
    0xf90e,
    0xe92f,
    0x99c8,
    0x89e9,
    0xb98a,
    0xa9ab,
    0x5844,
    0x4865,
    0x7806,
    0x6827,
    0x18c0,
    0x08e1,
    0x3882,
    0x28a3,
    0xcb7d,
    0xdb5c,
    0xeb3f,
    0xfb1e,
    0x8bf9,
    0x9bd8,
    0xabbb,
    0xbb9a,
    0x4a75,
    0x5a54,
    0x6a37,
    0x7a16,
    0x0af1,
    0x1ad0,
    0x2ab3,
    0x3a92,
    0xfd2e,
    0xed0f,
    0xdd6c,
    0xcd4d,
    0xbdaa,
    0xad8b,
    0x9de8,
    0x8dc9,
    0x7c26,
    0x6c07,
    0x5c64,
    0x4c45,
    0x3ca2,
    0x2c83,
    0x1ce0,
    0x0cc1,
    0xef1f,
    0xff3e,
    0xcf5d,
    0xdf7c,
    0xaf9b,
    0xbfba,
    0x8fd9,
    0x9ff8,
    0x6e17,
    0x7e36,
    0x4e55,
    0x5e74,
    0x2e93,
    0x3eb2,
    0x0ed1,
    0x1ef0
]);
function crc16(data) {
    if (!(data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"])) {
        data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(data);
    }
    let crc = 0;
    for(let index = 0; index < data.length; index++){
        const byte = data[index];
        crc = (TABLE[(crc >> 8 ^ byte) & 0xff] ^ crc << 8) & 0xffff;
    }
    return crc;
}
function getMethodId(name) {
    return crc16(name) & 0xffff | 0x10000;
}
exports.getMethodId = getMethodId;
}),
"[project]/node_modules/@ton/core/dist/crypto/safeSign.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [client] (ecmascript)");
"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.safeSignVerify = exports.safeSign = void 0;
const crypto_1 = (()=>{
    const e = new Error("Cannot find module '@ton/crypto'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const MIN_SEED_LENGTH = 8;
const MAX_SEED_LENGTH = 64;
function createSafeSignHash(cell, seed) {
    let seedData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from(seed);
    if (seedData.length > MAX_SEED_LENGTH) {
        throw Error('Seed can\t be longer than 64 bytes');
    }
    if (seedData.length < MIN_SEED_LENGTH) {
        throw Error('Seed must be at least 8 bytes');
    }
    return (0, crypto_1.sha256_sync)(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Buffer"].from([
            0xff,
            0xff
        ]),
        seedData,
        cell.hash()
    ]));
}
function safeSign(cell, secretKey, seed = 'ton-safe-sign-magic') {
    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
}
exports.safeSign = safeSign;
function safeSignVerify(cell, signature, publicKey, seed = 'ton-safe-sign-magic') {
    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
}
exports.safeSignVerify = safeSignVerify;
}),
"[project]/node_modules/@ton/core/dist/index.js [client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTupleItem = exports.parseTupleItem = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
// Address
var Address_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/Address.js [client] (ecmascript)");
Object.defineProperty(exports, "Address", {
    enumerable: true,
    get: function() {
        return Address_1.Address;
    }
});
Object.defineProperty(exports, "address", {
    enumerable: true,
    get: function() {
        return Address_1.address;
    }
});
var ExternalAddress_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/ExternalAddress.js [client] (ecmascript)");
Object.defineProperty(exports, "ExternalAddress", {
    enumerable: true,
    get: function() {
        return ExternalAddress_1.ExternalAddress;
    }
});
var ADNLAddress_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/ADNLAddress.js [client] (ecmascript)");
Object.defineProperty(exports, "ADNLAddress", {
    enumerable: true,
    get: function() {
        return ADNLAddress_1.ADNLAddress;
    }
});
var contractAddress_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/address/contractAddress.js [client] (ecmascript)");
Object.defineProperty(exports, "contractAddress", {
    enumerable: true,
    get: function() {
        return contractAddress_1.contractAddress;
    }
});
// BitString
var BitString_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitString.js [client] (ecmascript)");
Object.defineProperty(exports, "BitString", {
    enumerable: true,
    get: function() {
        return BitString_1.BitString;
    }
});
var BitReader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitReader.js [client] (ecmascript)");
Object.defineProperty(exports, "BitReader", {
    enumerable: true,
    get: function() {
        return BitReader_1.BitReader;
    }
});
var BitBuilder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/BitBuilder.js [client] (ecmascript)");
Object.defineProperty(exports, "BitBuilder", {
    enumerable: true,
    get: function() {
        return BitBuilder_1.BitBuilder;
    }
});
// Cell
var Builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Builder.js [client] (ecmascript)");
Object.defineProperty(exports, "Builder", {
    enumerable: true,
    get: function() {
        return Builder_1.Builder;
    }
});
Object.defineProperty(exports, "beginCell", {
    enumerable: true,
    get: function() {
        return Builder_1.beginCell;
    }
});
var Slice_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Slice.js [client] (ecmascript)");
Object.defineProperty(exports, "Slice", {
    enumerable: true,
    get: function() {
        return Slice_1.Slice;
    }
});
var CellType_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/CellType.js [client] (ecmascript)");
Object.defineProperty(exports, "CellType", {
    enumerable: true,
    get: function() {
        return CellType_1.CellType;
    }
});
var Cell_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/Cell.js [client] (ecmascript)");
Object.defineProperty(exports, "Cell", {
    enumerable: true,
    get: function() {
        return Cell_1.Cell;
    }
});
// Dict
var Dictionary_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/Dictionary.js [client] (ecmascript)");
Object.defineProperty(exports, "Dictionary", {
    enumerable: true,
    get: function() {
        return Dictionary_1.Dictionary;
    }
});
// Exotics
var exoticMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleProof.js [client] (ecmascript)");
Object.defineProperty(exports, "exoticMerkleProof", {
    enumerable: true,
    get: function() {
        return exoticMerkleProof_1.exoticMerkleProof;
    }
});
Object.defineProperty(exports, "convertToMerkleProof", {
    enumerable: true,
    get: function() {
        return exoticMerkleProof_1.convertToMerkleProof;
    }
});
var exoticMerkleUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticMerkleUpdate.js [client] (ecmascript)");
Object.defineProperty(exports, "exoticMerkleUpdate", {
    enumerable: true,
    get: function() {
        return exoticMerkleUpdate_1.exoticMerkleUpdate;
    }
});
var exoticPruned_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/boc/cell/exoticPruned.js [client] (ecmascript)");
Object.defineProperty(exports, "exoticPruned", {
    enumerable: true,
    get: function() {
        return exoticPruned_1.exoticPruned;
    }
});
// Merkle trees
var generateMerkleProof_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/generateMerkleProof.js [client] (ecmascript)");
Object.defineProperty(exports, "generateMerkleProof", {
    enumerable: true,
    get: function() {
        return generateMerkleProof_1.generateMerkleProof;
    }
});
Object.defineProperty(exports, "generateMerkleProofDirect", {
    enumerable: true,
    get: function() {
        return generateMerkleProof_1.generateMerkleProofDirect;
    }
});
var generateMerkleUpdate_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/dict/generateMerkleUpdate.js [client] (ecmascript)");
Object.defineProperty(exports, "generateMerkleUpdate", {
    enumerable: true,
    get: function() {
        return generateMerkleUpdate_1.generateMerkleUpdate;
    }
});
var tuple_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/tuple/tuple.js [client] (ecmascript)");
Object.defineProperty(exports, "parseTuple", {
    enumerable: true,
    get: function() {
        return tuple_1.parseTuple;
    }
});
Object.defineProperty(exports, "serializeTuple", {
    enumerable: true,
    get: function() {
        return tuple_1.serializeTuple;
    }
});
Object.defineProperty(exports, "parseTupleItem", {
    enumerable: true,
    get: function() {
        return tuple_1.parseTupleItem;
    }
});
Object.defineProperty(exports, "serializeTupleItem", {
    enumerable: true,
    get: function() {
        return tuple_1.serializeTupleItem;
    }
});
var reader_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/tuple/reader.js [client] (ecmascript)");
Object.defineProperty(exports, "TupleReader", {
    enumerable: true,
    get: function() {
        return reader_1.TupleReader;
    }
});
var builder_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/tuple/builder.js [client] (ecmascript)");
Object.defineProperty(exports, "TupleBuilder", {
    enumerable: true,
    get: function() {
        return builder_1.TupleBuilder;
    }
});
// Types
__exportStar(__turbopack_context__.r("[project]/node_modules/@ton/core/dist/types/_export.js [client] (ecmascript)"), exports);
var openContract_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/contract/openContract.js [client] (ecmascript)");
Object.defineProperty(exports, "openContract", {
    enumerable: true,
    get: function() {
        return openContract_1.openContract;
    }
});
var ComputeError_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/contract/ComputeError.js [client] (ecmascript)");
Object.defineProperty(exports, "ComputeError", {
    enumerable: true,
    get: function() {
        return ComputeError_1.ComputeError;
    }
});
// Utility
var convert_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/convert.js [client] (ecmascript)");
Object.defineProperty(exports, "toNano", {
    enumerable: true,
    get: function() {
        return convert_1.toNano;
    }
});
Object.defineProperty(exports, "fromNano", {
    enumerable: true,
    get: function() {
        return convert_1.fromNano;
    }
});
var crc16_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/crc16.js [client] (ecmascript)");
Object.defineProperty(exports, "crc16", {
    enumerable: true,
    get: function() {
        return crc16_1.crc16;
    }
});
var crc32c_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/crc32c.js [client] (ecmascript)");
Object.defineProperty(exports, "crc32c", {
    enumerable: true,
    get: function() {
        return crc32c_1.crc32c;
    }
});
var base32_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/base32.js [client] (ecmascript)");
Object.defineProperty(exports, "base32Decode", {
    enumerable: true,
    get: function() {
        return base32_1.base32Decode;
    }
});
Object.defineProperty(exports, "base32Encode", {
    enumerable: true,
    get: function() {
        return base32_1.base32Encode;
    }
});
var getMethodId_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/utils/getMethodId.js [client] (ecmascript)");
Object.defineProperty(exports, "getMethodId", {
    enumerable: true,
    get: function() {
        return getMethodId_1.getMethodId;
    }
});
// Crypto
var safeSign_1 = __turbopack_context__.r("[project]/node_modules/@ton/core/dist/crypto/safeSign.js [client] (ecmascript)");
Object.defineProperty(exports, "safeSign", {
    enumerable: true,
    get: function() {
        return safeSign_1.safeSign;
    }
});
Object.defineProperty(exports, "safeSignVerify", {
    enumerable: true,
    get: function() {
        return safeSign_1.safeSignVerify;
    }
});
}),
]);

//# sourceMappingURL=node_modules_%40ton_core_dist_58595048._.js.map